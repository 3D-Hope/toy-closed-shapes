, and (3) maintaining adequate play space. These are the foundation - without a kids_bed and safe heights, the room is fundamentally inappropriate for a toddler.
{
    "id": "SC3",
    "name": "enhanced_play_space_requirement",
    "description": "At least 50% of the floor area must remain unoccupied by furniture to provide ample space for a toddler's play, movement, and developmental activities. This is increased from the initial 40% threshold based on observed model performance."
},
{
    "id": "SC4",
    "name": "furniture_height_strict_enforcement",
    "description": "All non-ceiling furniture (excluding ceiling_lamp and pendant_lamp) must have height <= 1.0m. This is stricter than the initial 1.2m limit to better ensure safety for a 2-year-old who is learning to climb."
},
{
    "id": "SR3",
    "constraint_id": "SC3",
    "name": "enhanced_play_space_requirement",
    "code": "import torch\nimport numpy as np\nfrom shapely.geometry import Polygon, box\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef floor_polygon_to_shapely(floor_polygon):\n    \"\"\"Convert floor_polygon to Shapely Polygon.\"\"\"\n    if isinstance(floor_polygon, torch.Tensor):\n        vertices = floor_polygon.cpu().numpy()\n    else:\n        vertices = np.array(floor_polygon)\n    \n    valid_mask = np.all(np.abs(vertices) < 999, axis=1)\n    vertices_clean = vertices[valid_mask]\n    \n    return Polygon(vertices_clean)\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Ensures at least 50% of floor area is unoccupied.\n    Returns: 0.0 if >= 50% free, negative penalty proportional to deficit.\n    '''\n    device = parsed_scenes['device']\n    positions = parsed_scenes['positions']  # (B, N, 3)\n    sizes = parsed_scenes['sizes']  # (B, N, 3) - half-extents\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B, N, _ = positions.shape\n    \n    rewards = torch.zeros(B, device=device)\n    target_free_ratio = 0.5\n    \n    for b in range(B):\n        floor_poly = floor_polygon_to_shapely(floor_polygons[b])\n        total_floor_area = floor_poly.area\n        \n        if total_floor_area == 0:\n            rewards[b] = 0.0\n            continue\n        \n        # Calculate occupied area by furniture (simplified bounding boxes)\n        occupied_area = 0.0\n        for n in range(N):\n            if is_empty[b, n]:\n                continue\n            \n            size = sizes[b, n].cpu().numpy()\n            x_size = 2 * float(size[0])\n            z_size = 2 * float(size[2])\n            obj_area = x_size * z_size\n            occupied_area += obj_area\n        \n        # Calculate free area ratio\n        free_area = max(0, total_floor_area - occupied_area)\n        free_ratio = free_area / total_floor_area\n        \n        # Reward: 0.0 if free_ratio >= 0.5, negative penalty for deficit\n        if free_ratio >= target_free_ratio:\n            rewards[b] = 0.0\n        else:\n            # Penalty proportional to how much below 50% we are\n            deficit = target_free_ratio - free_ratio\n            # Scale: -10.0 per 0.1 (10%) deficit, capped at -5.0\n            rewards[b] = max(-5.0, -10.0 * deficit)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    # Scene 1: Minimal furniture - should have >50% free space (reward = 0.0)\n    num_objects_1 = 2\n    class_label_indices_1 = [11, 12]  # kids_bed, nightstand\n    translations_1 = [(1.0, 0.3, 1.0), (2.5, 0.25, 1.0)]\n    sizes_1 = [(0.8, 0.3, 1.0), (0.3, 0.25, 0.3)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Moderate furniture - borderline case\n    num_objects_2 = 5\n    class_label_indices_2 = [11, 12, 20, 5, 13]\n    translations_2 = [(1.0, 0.3, 1.0), (2.5, 0.25, 1.0), (0.5, 0.5, 3.0), (3.5, 0.5, 1.0), (2.0, 2.5, 2.0)]\n    sizes_2 = [(0.8, 0.3, 1.0), (0.3, 0.25, 0.3), (0.8, 0.5, 0.6), (0.4, 0.5, 0.4), (0.2, 0.1, 0.2)]\n    orientations_2 = [(1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Many large furniture - should violate constraint\n    num_objects_3 = 8\n    class_label_indices_3 = [11, 20, 20, 2, 2, 12, 12, 5]\n    translations_3 = [(2.0, 0.3, 2.0), (0.5, 0.5, 0.5), (3.8, 0.5, 0.5), (0.5, 0.45, 3.8), (3.8, 0.45, 3.8), (0.5, 0.3, 2.0), (3.8, 0.3, 2.0), (2.0, 0.35, 3.8)]\n    sizes_3 = [(1.0, 0.3, 1.4), (1.0, 0.5, 0.8), (1.0, 0.5, 0.8), (0.9, 0.45, 0.7), (0.9, 0.45, 0.7), (0.4, 0.3, 0.4), (0.4, 0.3, 0.4), (0.6, 0.35, 0.6)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [0.0 or small negative, moderate negative, large negative]\")\n    assert rewards.shape[0] == 3, f\"Expected 3 rewards, got {rewards.shape[0]}\"\n    assert rewards[0] >= -1.0, f\"Scene 1 (minimal furniture) should have reward >= -1.0, got {rewards[0]}\"\n    assert -5.0 <= rewards[1] <= 0.0, f\"Scene 2 reward should be in [-5.0, 0.0], got {rewards[1]}\"\n    assert rewards[2] < rewards[1], f\"Scene 3 (many furniture) should have worse reward than Scene 2, got {rewards[2]} vs {rewards[1]}\"\n    print(\"All tests passed for enhanced_play_space_requirement!\")",
    "success_threshold": 0.0
},
{
    "id": "SR4",
    "constraint_id": "SC4",
    "name": "furniture_height_strict_enforcement",
    "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Strict enforcement: all non-ceiling furniture must have height <= 1.0m.\n    Returns: 0.0 if all furniture satisfies constraint,\n    negative penalty proportional to violations.\n    '''\n    device = parsed_scenes['device']\n    sizes = parsed_scenes['sizes']  # (B, N, 3) - half-extents\n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B, N, _ = sizes.shape\n    \n    # Find ceiling lamp and pendant lamp indices\n    ceiling_lamp_idx = None\n    pendant_lamp_idx = None\n    for idx, label in idx_to_labels.items():\n        if label == 'ceiling_lamp':\n            ceiling_lamp_idx = idx\n        elif label == 'pendant_lamp':\n            pendant_lamp_idx = idx\n    \n    # Full height = 2 * y_size\n    heights = 2 * sizes[:, :, 1]  # (B, N)\n    max_height = 1.0\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Create mask for non-empty, non-ceiling furniture\n        non_ceiling_mask = ~is_empty[b]\n        \n        if ceiling_lamp_idx is not None:\n            is_ceiling_lamp = one_hot[b, :, ceiling_lamp_idx].bool()\n            non_ceiling_mask = non_ceiling_mask & ~is_ceiling_lamp\n        \n        if pendant_lamp_idx is not None:\n            is_pendant_lamp = one_hot[b, :, pendant_lamp_idx].bool()\n            non_ceiling_mask = non_ceiling_mask & ~is_pendant_lamp\n        \n        if non_ceiling_mask.sum() == 0:\n            rewards[b] = 0.0\n            continue\n        \n        # Check height violations for non-ceiling furniture\n        furniture_heights = heights[b, non_ceiling_mask]\n        violations = torch.clamp(furniture_heights - max_height, min=0.0)\n        \n        if violations.sum() == 0:\n            # All furniture satisfies constraint\n            rewards[b] = 0.0\n        else:\n            # Penalty: -1.5 per meter of violation, summed across all violating furniture\n            total_violation = violations.sum().item()\n            rewards[b] = -1.5 * total_violation\n            # Cap penalty at -5.0\n            rewards[b] = max(rewards[b], -5.0)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    # Scene 1: All furniture meets height constraint (should get reward 0.0)\n    num_objects_1 = 4\n    class_label_indices_1 = [11, 12, 5, 13]\n    translations_1 = [(1.0, 0.3, 1.0), (2.5, 0.25, 1.0), (0.5, 0.4, 3.0), (3.0, 2.5, 2.0)]\n    sizes_1 = [(0.8, 0.3, 1.0), (0.3, 0.25, 0.3), (0.4, 0.4, 0.4), (0.2, 0.1, 0.2)]  # Heights: 0.6m, 0.5m, 0.8m, (ceiling)\n    orientations_1 = [(1, 0), (1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: One furniture violates (wardrobe 1.6m, violation = 0.6m, penalty ~ -0.9)\n    num_objects_2 = 3\n    class_label_indices_2 = [11, 20, 12]\n    translations_2 = [(1.0, 0.3, 1.0), (2.5, 0.8, 1.0), (0.5, 0.25, 3.0)]\n    sizes_2 = [(0.8, 0.3, 1.0), (0.8, 0.8, 0.6), (0.3, 0.25, 0.3)]  # Heights: 0.6m, 1.6m (violates by 0.6m), 0.5m\n    orientations_2 = [(1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Multiple furniture violate\n    num_objects_3 = 3\n    class_label_indices_3 = [20, 20, 12]\n    translations_3 = [(1.0, 0.9, 1.0), (2.5, 0.85, 3.0), (0.5, 0.25, 2.0)]\n    sizes_3 = [(0.8, 0.9, 0.6), (0.8, 0.85, 0.6), (0.3, 0.25, 0.3)]  # Heights: 1.8m (violates 0.8m), 1.7m (violates 0.7m), 0.5m\n    orientations_3 = [(1, 0), (1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [0.0, ~-0.9, ~-2.25]\")\n    assert rewards.shape[0] == 3, f\"Expected 3 rewards, got {rewards.shape[0]}\"\n    assert torch.isclose(rewards[0], torch.tensor(0.0), atol=0.01), f\"Scene 1 (all heights <= 1.0m) should have reward 0.0, got {rewards[0]}\"\n    assert -1.0 <= rewards[1] <= -0.8, f\"Scene 2 (0.6m violation) should have reward ~-0.9, got {rewards[1]}\"\n    assert -2.5 <= rewards[2] <= -2.0, f\"Scene 3 (1.5m total violations) should have reward ~-2.25, got {rewards[2]}\"\n    print(\"All tests passed for furniture_height_strict_enforcement!\")",
    "success_threshold": 0.0
}