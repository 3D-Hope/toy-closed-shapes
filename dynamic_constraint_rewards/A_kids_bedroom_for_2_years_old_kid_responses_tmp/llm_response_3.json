{
    "curriculum": {
        "stage1": "Establish fundamental identity and critical safety constraints for a 2-year-old's bedroom. Focus on: (1) ensuring kids_bed presence instead of adult beds, (2) enforcing safe furniture heights, particularly for nightstands and other accessible furniture",
        "stage2": "Maintaining adequate play space. Focus on: (1) ensuring at least 50% of the floor area remains unoccupied by furniture to provide ample space for a toddler's play, movement, and developmental activities.",
        "stage3": "Refine storage solutions and furniture selection. Ensure children-appropriate storage (children_cabinet) is preferred, eliminate remaining hazardous furnitures. Focus on furniture placement relative to walls, ensuring adequate clearances, optimizing accessibility paths."
    },
    "constraints": [
        {
            "id": "SC1",
            "name": "kids_bed_required",
            "description": "The room must contain exactly one kids_bed (class index 11). This is the most critical constraint - a 2-year-old's bedroom must have age-appropriate sleeping furniture, not adult beds."
        },
        {
            "id": "SC2",
            "name": "strict_nightstand_height_limit",
            "description": "All nightstands (class index 12) must have height <= 0.6m to prevent climbing hazards and ensure safe accessibility for a 2-year-old. This is more strictly enforced than general furniture height limits."
        }
    ],
    "rewards": [
        {
            "id": "SR1",
            "constraint_id": "SC1",
            "name": "kids_bed_required",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Strong reward for having exactly one kids_bed, heavy penalty otherwise.\n    Returns: 0.0 if kids_bed count = 1, negative penalty otherwise.\n    Penalty increases with deviation from target count of 1.\n    '''\n    device = parsed_scenes['device']\n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B, N, num_classes = one_hot.shape\n    \n    # Find kids_bed index\n    kids_bed_idx = None\n    for idx, label in idx_to_labels.items():\n        if label == 'kids_bed':\n            kids_bed_idx = idx\n            break\n    \n    if kids_bed_idx is None:\n        return torch.full((B,), -10.0, device=device)\n    \n    # Count kids_beds (not empty and class matches)\n    kids_bed_mask = one_hot[:, :, kids_bed_idx] * (~is_empty)  # (B, N)\n    kids_bed_count = kids_bed_mask.sum(dim=1)  # (B,)\n    \n    # Reward: 0.0 for exactly 1 kids_bed, -5.0 for 0, -3.0 for 2+\n    rewards = torch.zeros(B, device=device)\n    rewards = torch.where(kids_bed_count == 0, torch.tensor(-5.0, device=device), rewards)\n    rewards = torch.where(kids_bed_count > 1, torch.tensor(-3.0, device=device), rewards)\n    # kids_bed_count == 1 remains 0.0 (success)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    # Scene 1: Exactly 1 kids_bed (should get reward 0.0)\n    num_objects_1 = 3\n    class_label_indices_1 = [11, 12, 13]  # kids_bed, nightstand, pendant_lamp\n    translations_1 = [(1.0, 0.3, 1.0), (2.5, 0.25, 1.0), (3.0, 2.5, 2.0)]\n    sizes_1 = [(0.8, 0.3, 1.0), (0.3, 0.25, 0.3), (0.2, 0.1, 0.2)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: No kids_bed (should get reward -5.0)\n    num_objects_2 = 3\n    class_label_indices_2 = [12, 20, 13]  # nightstand, wardrobe, pendant_lamp\n    translations_2 = [(1.0, 0.25, 1.0), (2.5, 1.0, 1.0), (3.0, 2.5, 2.0)]\n    sizes_2 = [(0.3, 0.25, 0.3), (0.8, 1.0, 0.6), (0.2, 0.1, 0.2)]\n    orientations_2 = [(1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Two kids_beds (should get reward -3.0)\n    num_objects_3 = 4\n    class_label_indices_3 = [11, 11, 12, 13]  # 2 kids_beds, nightstand, pendant_lamp\n    translations_3 = [(1.0, 0.3, 1.0), (3.0, 0.3, 1.0), (2.5, 0.25, 1.0), (3.0, 2.5, 2.0)]\n    sizes_3 = [(0.8, 0.3, 1.0), (0.8, 0.3, 1.0), (0.3, 0.25, 0.3), (0.2, 0.1, 0.2)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [0.0, -5.0, -3.0]\")\n    assert rewards.shape[0] == 3, f\"Expected 3 rewards, got {rewards.shape[0]}\"\n    assert torch.isclose(rewards[0], torch.tensor(0.0), atol=0.01), f\"Scene 1 (1 kids_bed) should have reward 0.0, got {rewards[0]}\"\n    assert torch.isclose(rewards[1], torch.tensor(-5.0), atol=0.01), f\"Scene 2 (0 kids_beds) should have reward -5.0, got {rewards[1]}\"\n    assert torch.isclose(rewards[2], torch.tensor(-3.0), atol=0.01), f\"Scene 3 (2 kids_beds) should have reward -3.0, got {rewards[2]}\"\n    print(\"All tests passed for kids_bed_required!\")",
            "success_threshold": 0.0
        },
        {
            "id": "SR2",
            "constraint_id": "SC2",
            "name": "strict_nightstand_height_limit",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Strict enforcement of nightstand height <= 0.6m.\n    Returns: 0.0 if all nightstands satisfy constraint or no nightstands present,\n    negative penalty proportional to violations.\n    '''\n    device = parsed_scenes['device']\n    sizes = parsed_scenes['sizes']  # (B, N, 3) - half-extents\n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B, N, _ = sizes.shape\n    \n    # Find nightstand index\n    nightstand_idx = None\n    for idx, label in idx_to_labels.items():\n        if label == 'nightstand':\n            nightstand_idx = idx\n            break\n    \n    if nightstand_idx is None:\n        return torch.zeros(B, device=device)\n    \n    # Full height = 2 * y_size\n    heights = 2 * sizes[:, :, 1]  # (B, N)\n    max_height = 0.6\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Find nightstands in this scene\n        is_nightstand = one_hot[b, :, nightstand_idx].bool() & ~is_empty[b]\n        \n        if is_nightstand.sum() == 0:\n            # No nightstands, constraint is satisfied\n            rewards[b] = 0.0\n        else:\n            # Check height constraint for nightstands\n            nightstand_heights = heights[b, is_nightstand]\n            violations = torch.clamp(nightstand_heights - max_height, min=0.0)  # Only positive violations\n            \n            if violations.sum() == 0:\n                # All nightstands satisfy constraint\n                rewards[b] = 0.0\n            else:\n                # Penalty: -2.0 per meter of violation, summed across all nightstands\n                total_violation = violations.sum().item()\n                rewards[b] = -2.0 * total_violation\n                # Cap penalty at -5.0 for extreme cases\n                rewards[b] = max(rewards[b], -5.0)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    # Scene 1: Nightstand with safe height 0.5m (should get reward 0.0)\n    num_objects_1 = 2\n    class_label_indices_1 = [11, 12]  # kids_bed, nightstand\n    translations_1 = [(1.0, 0.3, 1.0), (2.5, 0.25, 1.0)]\n    sizes_1 = [(0.8, 0.3, 1.0), (0.3, 0.25, 0.3)]  # Nightstand height = 0.5m\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Nightstand too tall 0.8m (should get reward ~ -0.4 = -2.0 * 0.2)\n    num_objects_2 = 2\n    class_label_indices_2 = [11, 12]  # kids_bed, nightstand\n    translations_2 = [(1.0, 0.3, 1.0), (2.5, 0.4, 1.0)]\n    sizes_2 = [(0.8, 0.3, 1.0), (0.3, 0.4, 0.3)]  # Nightstand height = 0.8m (violation = 0.2m)\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No nightstand (should get reward 0.0)\n    num_objects_3 = 2\n    class_label_indices_3 = [11, 5]  # kids_bed, children_cabinet\n    translations_3 = [(1.0, 0.3, 1.0), (2.5, 0.5, 3.0)]\n    sizes_3 = [(0.8, 0.3, 1.0), (0.4, 0.5, 0.4)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [0.0, ~-0.4, 0.0]\")\n    assert rewards.shape[0] == 3, f\"Expected 3 rewards, got {rewards.shape[0]}\"\n    assert torch.isclose(rewards[0], torch.tensor(0.0), atol=0.01), f\"Scene 1 (height 0.5m) should have reward 0.0, got {rewards[0]}\"\n    assert -0.5 <= rewards[1] <= -0.3, f\"Scene 2 (height 0.8m) should have reward ~-0.4, got {rewards[1]}\"\n    assert torch.isclose(rewards[2], torch.tensor(0.0), atol=0.01), f\"Scene 3 (no nightstand) should have reward 0.0, got {rewards[2]}\"\n    print(\"All tests passed for strict_nightstand_height_limit!\")",
            "success_threshold": 0.0
        }
    ]
}