{
    "constraints": [
        {
            "id": "SC1",
            "name": "kids_bed_present",
            "description": "Verifies that at least one kids_bed exists in the bedroom scene. Since kids_bed will be inpainted, this constraint ensures the model doesn't generate additional inappropriate bed types or remove the kids_bed."
        },
        {
            "id": "SC2",
            "name": "table_height_safety_gradient",
            "description": "Encourages tables to be positioned higher for child safety. Rather than a hard threshold, this uses a gradient reward that increases with table height, making it easier for the model to learn incrementally. Tables above 1.1m get maximum reward, tables between 0.9-1.1m get partial reward, and tables below 0.9m get penalties."
        },
        {
            "id": "SC3",
            "name": "appropriate_furniture_for_kids_room",
            "description": "Ensures the room contains child-appropriate furniture. Since kids_bed is inpainted, this checks that if tables exist, they should be positioned safely. This combines the existence check with safety in a softer way."
        }
    ],
    "rewards": [
        {
            "id": "SR1",
            "constraint_id": "SC1",
            "name": "kids_bed_present",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward function to verify that at least one kids_bed exists in the scene.\n    \n    Since kids_bed is inpainted, this primarily prevents the model from\n    generating inappropriate additional beds or removing the kids_bed.\n    \n    Returns:\n        1.0 if kids_bed exists\n        -1.0 if no kids_bed exists\n    '''\n    \n    device = parsed_scenes['device']\n    object_indices = parsed_scenes['object_indices']  # (B, N)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    \n    B = object_indices.shape[0]\n    \n    # Get kids_bed class index\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    kids_bed_idx = labels_to_idx['kids_bed']\n    \n    # Initialize rewards\n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Check if kids_bed exists\n        kids_bed_mask = (object_indices[b] == kids_bed_idx) & (~is_empty[b])\n        has_kids_bed = kids_bed_mask.any()\n        \n        rewards[b] = 1.0 if has_kids_bed else -1.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test function for kids_bed presence constraint.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    kids_bed_idx = labels_to_idx['kids_bed']\n    table_idx = labels_to_idx['table']\n    nightstand_idx = labels_to_idx['nightstand']\n    wardrobe_idx = labels_to_idx['wardrobe']\n    \n    # Scene 1: Has kids_bed\n    num_objects_1 = 3\n    class_label_indices_1 = [kids_bed_idx, table_idx, nightstand_idx]\n    translations_1 = [(0, 0.3, 0), (1.5, 0.75, 0), (-1.5, 0.3, 0)]\n    sizes_1 = [(0.9, 0.3, 0.75), (0.4, 0.75, 0.4), (0.3, 0.3, 0.3)]\n    orientations_1 = [(1.0, 0.0), (1.0, 0.0), (1.0, 0.0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: No kids_bed\n    num_objects_2 = 3\n    class_label_indices_2 = [table_idx, nightstand_idx, wardrobe_idx]\n    translations_2 = [(0, 0.75, 0), (1.5, 0.3, 0), (-1.5, 0.5, 0)]\n    sizes_2 = [(0.4, 0.75, 0.4), (0.3, 0.3, 0.3), (0.5, 0.5, 1.0)]\n    orientations_2 = [(1.0, 0.0), (1.0, 0.0), (1.0, 0.0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Has kids_bed\n    num_objects_3 = 2\n    class_label_indices_3 = [kids_bed_idx, wardrobe_idx]\n    translations_3 = [(0, 0.3, 0), (1.5, 0.5, 0)]\n    sizes_3 = [(0.9, 0.3, 0.75), (0.5, 0.5, 1.0)]\n    orientations_3 = [(1.0, 0.0), (1.0, 0.0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(f\"Scene 1 (has kids_bed): {rewards[0].item()}\")\n    print(f\"Scene 2 (no kids_bed): {rewards[1].item()}\")\n    print(f\"Scene 3 (has kids_bed): {rewards[2].item()}\")\n    \n    assert rewards.shape[0] == 3, \"Should have 3 scenes\"\n    assert rewards[0].item() == 1.0, f\"Scene 1: Has kids_bed, should return 1.0, got {rewards[0].item()}\"\n    assert rewards[1].item() == -1.0, f\"Scene 2: No kids_bed, should return -1.0, got {rewards[1].item()}\"\n    assert rewards[2].item() == 1.0, f\"Scene 3: Has kids_bed, should return 1.0, got {rewards[2].item()}\"\n    \n    print(\"All tests passed!\")",
            "success_threshold": 1.0
        },
        {
            "id": "SR2",
            "constraint_id": "SC2",
            "name": "table_height_safety_gradient",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Gradient reward for table height safety with smoother learning curve.\n    \n    Uses a continuous reward function:\n    - Tables > 1.15m: reward = 1.0 (very safe)\n    - Tables 1.1-1.15m: reward = 0.5-1.0 (safe)\n    - Tables 0.9-1.1m: reward = 0.0-0.5 (marginal)\n    - Tables 0.75-0.9m: reward = -0.3-0.0 (standard but unsafe)\n    - Tables < 0.75m: reward = -0.5 (very unsafe)\n    - No tables: reward = 0.0 (neutral, not applicable)\n    \n    This gradient makes it easier for the model to learn incrementally.\n    '''\n    \n    device = parsed_scenes['device']\n    positions = parsed_scenes['positions']  # (B, N, 3)\n    sizes = parsed_scenes['sizes']  # (B, N, 3)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    object_indices = parsed_scenes['object_indices']  # (B, N)\n    \n    B, N = positions.shape[:2]\n    \n    # Get table-type class indices\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    table_classes = [labels_to_idx['table'], labels_to_idx['desk'], labels_to_idx['dressing_table']]\n    \n    # Initialize rewards\n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Find table-type objects in the scene\n        table_mask = torch.zeros(N, dtype=torch.bool, device=device)\n        for table_class in table_classes:\n            table_mask |= (object_indices[b] == table_class) & (~is_empty[b])\n        \n        if not table_mask.any():\n            # No tables - neutral (constraint not applicable)\n            rewards[b] = 0.0\n            continue\n        \n        # Process all tables in the scene\n        table_indices = torch.where(table_mask)[0]\n        total_reward = 0.0\n        \n        for table_idx in table_indices:\n            # Calculate table top height\n            table_centroid_y = positions[b, table_idx, 1]\n            table_half_height = sizes[b, table_idx, 1]\n            table_top_y = table_centroid_y + table_half_height\n            \n            # Gradient reward based on height\n            if table_top_y >= 1.15:\n                # Very safe height\n                table_reward = 1.0\n            elif table_top_y >= 1.1:\n                # Safe height - linear interpolation\n                table_reward = 0.5 + (table_top_y - 1.1) / 0.05 * 0.5\n            elif table_top_y >= 0.9:\n                # Marginal height - linear interpolation\n                table_reward = (table_top_y - 0.9) / 0.2 * 0.5\n            elif table_top_y >= 0.75:\n                # Standard table height but unsafe for toddlers\n                table_reward = -0.3 + (table_top_y - 0.75) / 0.15 * 0.3\n            else:\n                # Very low table - very unsafe\n                table_reward = -0.5\n            \n            total_reward += table_reward\n        \n        # Average reward across all tables\n        rewards[b] = total_reward / len(table_indices)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test function for table height safety gradient constraint.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    kids_bed_idx = labels_to_idx['kids_bed']\n    table_idx = labels_to_idx['table']\n    nightstand_idx = labels_to_idx['nightstand']\n    \n    # Scene 1: Very safe table (top at 1.5m)\n    num_objects_1 = 3\n    class_label_indices_1 = [kids_bed_idx, table_idx, nightstand_idx]\n    translations_1 = [(0, 0.3, 0), (1.5, 0.75, 0), (-1.5, 0.3, 0)]\n    sizes_1 = [(0.9, 0.3, 0.75), (0.4, 0.75, 0.4), (0.3, 0.3, 0.3)]\n    orientations_1 = [(1.0, 0.0), (1.0, 0.0), (1.0, 0.0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Standard table height (top at 0.75m - typical)\n    num_objects_2 = 3\n    class_label_indices_2 = [kids_bed_idx, table_idx, nightstand_idx]\n    translations_2 = [(0, 0.3, 0), (1.5, 0.375, 0), (-1.5, 0.3, 0)]\n    sizes_2 = [(0.9, 0.3, 0.75), (0.4, 0.375, 0.4), (0.3, 0.3, 0.3)]\n    orientations_2 = [(1.0, 0.0), (1.0, 0.0), (1.0, 0.0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No table\n    num_objects_3 = 2\n    class_label_indices_3 = [kids_bed_idx, nightstand_idx]\n    translations_3 = [(0, 0.3, 0), (1.5, 0.3, 0)]\n    sizes_3 = [(0.9, 0.3, 0.75), (0.3, 0.3, 0.3)]\n    orientations_3 = [(1.0, 0.0), (1.0, 0.0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Scene 4: Marginal table height (top at 1.0m)\n    num_objects_4 = 2\n    class_label_indices_4 = [kids_bed_idx, table_idx]\n    translations_4 = [(0, 0.3, 0), (1.5, 0.5, 0)]\n    sizes_4 = [(0.9, 0.3, 0.75), (0.4, 0.5, 0.4)]\n    orientations_4 = [(1.0, 0.0), (1.0, 0.0)]\n    scene_4 = create_scene(room_type, num_objects_4, class_label_indices_4, translations_4, sizes_4, orientations_4)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k], scene_4[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(f\"Scene 1 (very safe table 1.5m): {rewards[0].item():.4f}\")\n    print(f\"Scene 2 (standard table 0.75m): {rewards[1].item():.4f}\")\n    print(f\"Scene 3 (no table): {rewards[2].item():.4f}\")\n    print(f\"Scene 4 (marginal table 1.0m): {rewards[3].item():.4f}\")\n    \n    assert rewards.shape[0] == 4, \"Should have 4 scenes\"\n    assert rewards[0].item() > 0.95, f\"Scene 1: Very safe table should have reward close to 1.0, got {rewards[0].item()}\"\n    assert -0.35 <= rewards[1].item() <= -0.25, f\"Scene 2: Standard table should have reward around -0.3, got {rewards[1].item()}\"\n    assert rewards[2].item() == 0.0, f\"Scene 3: No table should return 0.0, got {rewards[2].item()}\"\n    assert 0.2 <= rewards[3].item() <= 0.3, f\"Scene 4: Marginal table should have reward around 0.25, got {rewards[3].item()}\"\n    assert rewards[0] > rewards[3] > rewards[2] > rewards[1], f\"Expected order: Scene 1 > Scene 4 > Scene 3 > Scene 2, got {rewards[0]:.3f}, {rewards[3]:.3f}, {rewards[2]:.3f}, {rewards[1]:.3f}\"\n    \n    print(\"All tests passed!\")",
            "success_threshold": 0.5
        },
        {
            "id": "SR3",
            "constraint_id": "SC3",
            "name": "combined_table_presence_and_safety",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Combined reward that considers both table presence and safety.\n    \n    This provides a holistic view:\n    - If tables exist and are safe (>1.1m): positive reward\n    - If tables exist but unsafe (<1.1m): negative reward\n    - If no tables exist: neutral (0.0)\n    \n    This helps the model understand the relationship between having tables\n    and positioning them safely.\n    '''\n    \n    device = parsed_scenes['device']\n    positions = parsed_scenes['positions']  # (B, N, 3)\n    sizes = parsed_scenes['sizes']  # (B, N, 3)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    object_indices = parsed_scenes['object_indices']  # (B, N)\n    \n    B, N = positions.shape[:2]\n    \n    # Get table-type class indices\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    table_classes = [labels_to_idx['table'], labels_to_idx['desk'], labels_to_idx['dressing_table']]\n    \n    # Initialize rewards\n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Find table-type objects\n        table_mask = torch.zeros(N, dtype=torch.bool, device=device)\n        for table_class in table_classes:\n            table_mask |= (object_indices[b] == table_class) & (~is_empty[b])\n        \n        if not table_mask.any():\n            # No tables - neutral\n            rewards[b] = 0.0\n            continue\n        \n        # Tables exist - check safety\n        table_indices = torch.where(table_mask)[0]\n        safe_count = 0\n        unsafe_count = 0\n        \n        for table_idx in table_indices:\n            table_centroid_y = positions[b, table_idx, 1]\n            table_half_height = sizes[b, table_idx, 1]\n            table_top_y = table_centroid_y + table_half_height\n            \n            if table_top_y >= 1.1:\n                safe_count += 1\n            else:\n                unsafe_count += 1\n        \n        total_tables = len(table_indices)\n        safe_ratio = safe_count / total_tables\n        \n        # Reward based on safety ratio\n        # All safe: +1.0, All unsafe: -1.0, Mixed: proportional\n        rewards[b] = 2.0 * safe_ratio - 1.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test function for combined table presence and safety.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    kids_bed_idx = labels_to_idx['kids_bed']\n    table_idx = labels_to_idx['table']\n    desk_idx = labels_to_idx['desk']\n    nightstand_idx = labels_to_idx['nightstand']\n    \n    # Scene 1: Safe table\n    num_objects_1 = 2\n    class_label_indices_1 = [kids_bed_idx, table_idx]\n    translations_1 = [(0, 0.3, 0), (1.5, 0.75, 0)]\n    sizes_1 = [(0.9, 0.3, 0.75), (0.4, 0.75, 0.4)]\n    orientations_1 = [(1.0, 0.0), (1.0, 0.0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Unsafe table\n    num_objects_2 = 2\n    class_label_indices_2 = [kids_bed_idx, table_idx]\n    translations_2 = [(0, 0.3, 0), (1.5, 0.375, 0)]\n    sizes_2 = [(0.9, 0.3, 0.75), (0.4, 0.375, 0.4)]\n    orientations_2 = [(1.0, 0.0), (1.0, 0.0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No table\n    num_objects_3 = 2\n    class_label_indices_3 = [kids_bed_idx, nightstand_idx]\n    translations_3 = [(0, 0.3, 0), (1.5, 0.3, 0)]\n    sizes_3 = [(0.9, 0.3, 0.75), (0.3, 0.3, 0.3)]\n    orientations_3 = [(1.0, 0.0), (1.0, 0.0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Scene 4: Mixed (one safe, one unsafe)\n    num_objects_4 = 3\n    class_label_indices_4 = [kids_bed_idx, table_idx, desk_idx]\n    translations_4 = [(0, 0.3, 0), (1.5, 0.75, 0), (-1.5, 0.375, 0)]\n    sizes_4 = [(0.9, 0.3, 0.75), (0.4, 0.75, 0.4), (0.5, 0.375, 0.5)]\n    orientations_4 = [(1.0, 0.0), (1.0, 0.0), (1.0, 0.0)]\n    scene_4 = create_scene(room_type, num_objects_4, class_label_indices_4, translations_4, sizes_4, orientations_4)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k], scene_4[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(f\"Scene 1 (safe table): {rewards[0].item():.4f}\")\n    print(f\"Scene 2 (unsafe table): {rewards[1].item():.4f}\")\n    print(f\"Scene 3 (no table): {rewards[2].item():.4f}\")\n    print(f\"Scene 4 (mixed): {rewards[3].item():.4f}\")\n    \n    assert rewards.shape[0] == 4, \"Should have 4 scenes\"\n    assert rewards[0].item() == 1.0, f\"Scene 1: Safe table should return 1.0, got {rewards[0].item()}\"\n    assert rewards[1].item() == -1.0, f\"Scene 2: Unsafe table should return -1.0, got {rewards[1].item()}\"\n    assert rewards[2].item() == 0.0, f\"Scene 3: No table should return 0.0, got {rewards[2].item()}\"\n    assert abs(rewards[3].item()) < 0.1, f\"Scene 4: Mixed should be close to 0.0, got {rewards[3].item()}\"\n    \n    print(\"All tests passed!\")",
            "success_threshold": 0.5
        }
    ]
}