
        User Prompt: Bedroom where all objects are close together to leave space for homeworkout
        Initial Constraints: {'constraints': [{'id': 'C1', 'name': 'furniture_clustering', 'description': 'Measures how closely furniture objects are grouped together. Calculates the compactness of furniture placement by measuring the average distance from each furniture piece to the centroid of all furniture. Lower average distance indicates tighter clustering.'}, {'id': 'C2', 'name': 'open_floor_area', 'description': 'Ensures there is a significant contiguous open floor space available for home workout activities. Calculates the largest rectangular or circular area on the floor that is free from furniture obstacles. Target minimum area should be approximately 2m x 2m (4 square meters) for basic workout space.'}, {'id': 'C3', 'name': 'workout_space_centrality', 'description': 'Verifies that the open workout space is accessible and not fragmented into corners. Measures whether the largest open area is reasonably central or at least has one dimension that allows for movement exercises (lunges, yoga, etc.).'}, {'id': 'C4', 'name': 'furniture_wall_proximity', 'description': 'Encourages furniture to be positioned near walls/boundaries rather than in the center of the room. Calculates the average minimum distance from each furniture piece to the nearest room boundary. Lower values indicate furniture is pushed toward perimeter, leaving center clear.'}, {'id': 'C5', 'name': 'minimum_workout_clearance', 'description': 'Ensures the workout area has sufficient vertical and horizontal clearance. Checks that the open space is free from overhead objects (like low pendant lamps) and has clear paths without narrow gaps between furniture that would impede movement.'}]}
        Initial Reward Functions: {'rewards': [{'id': 'R1', 'constraint_id': 'C1', 'name': 'furniture_clustering_reward', 'code': 'import torch\nimport numpy as np\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Reward for furniture clustering - measures how tightly furniture is grouped.\n    Lower average distance from furniture centroid = higher reward.\n    \n    Input:\n        - parsed_scenes: dict with scene data\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor vertices\n        - **kwargs: additional arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,) - higher values for tighter clustering\n    \'\'\'\n    positions = parsed_scenes[\'positions\']  # (B, N, 3)\n    is_empty = parsed_scenes[\'is_empty\']  # (B, N)\n    device = parsed_scenes[\'device\']\n    \n    B, N, _ = positions.shape\n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Get non-empty furniture positions (only x, z coordinates for floor plane)\n        valid_mask = ~is_empty[b]\n        valid_positions = positions[b][valid_mask]  # (num_valid, 3)\n        \n        if valid_positions.shape[0] <= 1:\n            # Need at least 2 objects to measure clustering\n            rewards[b] = 0.0\n            continue\n        \n        # Compute centroid of all furniture (x, z plane)\n        xz_positions = valid_positions[:, [0, 2]]  # (num_valid, 2)\n        centroid = xz_positions.mean(dim=0)  # (2,)\n        \n        # Calculate average distance from centroid\n        distances = torch.norm(xz_positions - centroid.unsqueeze(0), dim=1)  # (num_valid,)\n        avg_distance = distances.mean()\n        \n        # Transform to reward: lower distance = higher reward\n        # Use exponential decay: reward = exp(-distance)\n        # Cap at reasonable maximum distance of 5m\n        avg_distance_capped = torch.clamp(avg_distance, 0, 5.0)\n        rewards[b] = torch.exp(-avg_distance_capped)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Test function for furniture clustering reward.\n    \'\'\'\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions["create_scene_for_testing"]["function"]\n    \n    # Scene 1: Tightly clustered furniture (should get high reward)\n    num_objects_1 = 3\n    class_label_indices_1 = [8, 12, 20]  # double_bed, nightstand, wardrobe\n    translations_1 = [(0.0, 0.5, 0.0), (0.5, 0.3, 0.5), (0.5, 1.0, -0.5)]\n    sizes_1 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Spread out furniture (should get lower reward)\n    num_objects_2 = 3\n    class_label_indices_2 = [8, 12, 20]\n    translations_2 = [(0.0, 0.5, 0.0), (3.0, 0.3, 3.0), (-3.0, 1.0, -3.0)]\n    sizes_2 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5)]\n    orientations_2 = [(1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Single object (edge case, should get 0)\n    num_objects_3 = 1\n    class_label_indices_3 = [8]\n    translations_3 = [(0.0, 0.5, 0.0)]\n    sizes_3 = [(1.0, 0.5, 1.0)]\n    orientations_3 = [(1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes[\'room_type\'] = room_type\n    parsed_scenes[\'device\'] = scene_1[\'device\']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print("Rewards:", rewards)\n    print("Scene 1 (clustered) reward:", rewards[0].item())\n    print("Scene 2 (spread) reward:", rewards[1].item())\n    print("Scene 3 (single object) reward:", rewards[2].item())\n    \n    # assert rewards.shape[0] == 3, f"Expected 3 rewards, got {rewards.shape[0]}"\n    # assert rewards[0] > rewards[1], f"Clustered furniture (reward={rewards[0].item():.4f}) should have higher reward than spread furniture (reward={rewards[1].item():.4f})"\n    # assert rewards[2] == 0.0, f"Single object should have reward 0, got {rewards[2].item()}"\n    # assert rewards[0] > 0.5, f"Tightly clustered furniture should have reward > 0.5, got {rewards[0].item():.4f}"\n    # assert rewards[1] < 0.5, f"Spread furniture should have reward < 0.5, got {rewards[1].item():.4f}"\n    \n    print("All tests passed!")', 'success_threshold': 0.6}, {'id': 'R2', 'constraint_id': 'C2', 'name': 'open_floor_area_reward', 'code': 'import torch\nimport numpy as np\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Reward for open floor area - measures largest contiguous open space.\n    Target: minimum 2m x 2m (4 sq meters) for workout space.\n    \n    Input:\n        - parsed_scenes: dict with scene data\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor vertices\n        - **kwargs: additional arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,) - higher for larger open areas\n    \'\'\'\n    positions = parsed_scenes[\'positions\']  # (B, N, 3)\n    sizes = parsed_scenes[\'sizes\']  # (B, N, 3)\n    is_empty = parsed_scenes[\'is_empty\']  # (B, N)\n    device = parsed_scenes[\'device\']\n    \n    B, N, _ = positions.shape\n    rewards = torch.zeros(B, device=device)\n    \n    # Target open area for workout (4 sq meters = 2m x 2m)\n    target_area = 4.0\n    \n    for b in range(B):\n        # Get valid furniture positions and sizes\n        valid_mask = ~is_empty[b]\n        valid_positions = positions[b][valid_mask]  # (num_valid, 3)\n        valid_sizes = sizes[b][valid_mask]  # (num_valid, 3)\n        \n        if valid_positions.shape[0] == 0:\n            # No furniture - entire floor is open\n            # Compute floor area from polygon\n            poly = np.array(floor_polygons)\n            floor_area = compute_polygon_area(poly)\n            rewards[b] = min(floor_area / target_area, 2.0)  # Cap at 2x target\n            continue\n        \n        # Estimate largest open area using grid-based approach\n        # Create occupancy grid\n        grid_res = 0.2  # 20cm resolution\n        \n        # Get floor bounds\n        poly = np.array(floor_polygons)\n        x_min, x_max = poly[:, 0].min(), poly[:, 0].max()\n        z_min, z_max = poly[:, 1].min(), poly[:, 1].max()\n        \n        # Create grid\n        x_range = torch.arange(x_min, x_max, grid_res, device=device)\n        z_range = torch.arange(z_min, z_max, grid_res, device=device)\n        grid_x, grid_z = torch.meshgrid(x_range, z_range, indexing=\'ij\')\n        grid_points = torch.stack([grid_x.flatten(), grid_z.flatten()], dim=1)  # (num_points, 2)\n        \n        # Mark occupied cells\n        occupied = torch.zeros(grid_points.shape[0], dtype=torch.bool, device=device)\n        \n        for i in range(valid_positions.shape[0]):\n            pos = valid_positions[i, [0, 2]]  # (x, z)\n            size = valid_sizes[i, [0, 2]]  # (sx/2, sz/2)\n            \n            # Check which grid points are inside this object\'s bounding box\n            dist = torch.abs(grid_points - pos.unsqueeze(0))\n            inside = (dist[:, 0] < size[0]) & (dist[:, 1] < size[1])\n            occupied |= inside\n        \n        # Count free cells\n        free_cells = (~occupied).sum().float()\n        cell_area = grid_res * grid_res\n        open_area = free_cells * cell_area\n        \n        # Compute reward based on open area\n        # Sigmoid-like function: reward increases with area, saturates above target\n        area_ratio = open_area / target_area\n        rewards[b] = torch.tanh(area_ratio)  # Bounded [0, 1]\n    \n    return rewards\n\ndef compute_polygon_area(vertices):\n    """Compute area of polygon using shoelace formula."""\n    x = vertices[:, 0]\n    y = vertices[:, 1]\n    return 0.5 * abs(sum(x[i] * y[i+1] - x[i+1] * y[i] for i in range(-1, len(x)-1)))\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Test function for open floor area reward.\n    \'\'\'\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions["create_scene_for_testing"]["function"]\n    \n    # Scene 1: Minimal furniture - large open space (should get high reward)\n    num_objects_1 = 2\n    class_label_indices_1 = [8, 12]  # bed and nightstand in corner\n    translations_1 = [(-2.0, 0.5, -2.0), (-2.5, 0.3, -1.0)]\n    sizes_1 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Many furniture pieces - limited open space (should get lower reward)\n    num_objects_2 = 5\n    class_label_indices_2 = [8, 12, 20, 7, 4]\n    translations_2 = [(0.0, 0.5, 0.0), (1.5, 0.3, 0.5), (-1.5, 1.0, 0.5), (0.0, 0.4, 2.0), (1.0, 0.5, -1.5)]\n    sizes_2 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5), (0.6, 0.4, 0.6), (0.4, 0.5, 0.4)]\n    orientations_2 = [(1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No furniture - maximum open space\n    num_objects_3 = 0\n    class_label_indices_3 = []\n    translations_3 = []\n    sizes_3 = []\n    orientations_3 = []\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes[\'room_type\'] = room_type\n    parsed_scenes[\'device\'] = scene_1[\'device\']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print("Rewards:", rewards)\n    print("Scene 1 (minimal furniture) reward:", rewards[0].item())\n    print("Scene 2 (many furniture) reward:", rewards[1].item())\n    print("Scene 3 (no furniture) reward:", rewards[2].item())\n    \n    # assert rewards.shape[0] == 3, f"Expected 3 rewards, got {rewards.shape[0]}"\n    # assert rewards[0] > rewards[1], f"Minimal furniture (reward={rewards[0].item():.4f}) should have higher reward than many furniture (reward={rewards[1].item():.4f})"\n    # assert rewards[2] >= rewards[0], f"No furniture (reward={rewards[2].item():.4f}) should have highest reward"\n    # assert rewards[1] >= 0.0, f"Reward should be non-negative, got {rewards[1].item():.4f}"\n    # assert rewards[2] <= 2.0, f"Reward should be capped, got {rewards[2].item():.4f}"\n    \n    print("All tests passed!")', 'success_threshold': 0.7}, {'id': 'R3', 'constraint_id': 'C3', 'name': 'workout_space_centrality_reward', 'code': 'import torch\nimport numpy as np\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Reward for workout space centrality - ensures open space is not just in corners.\n    Measures how central the largest free region is.\n    \n    Input:\n        - parsed_scenes: dict with scene data\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor vertices\n        - **kwargs: additional arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,) - higher for more central open spaces\n    \'\'\'\n    positions = parsed_scenes[\'positions\']  # (B, N, 3)\n    sizes = parsed_scenes[\'sizes\']  # (B, N, 3)\n    is_empty = parsed_scenes[\'is_empty\']  # (B, N)\n    device = parsed_scenes[\'device\']\n    \n    B, N, _ = positions.shape\n    rewards = torch.zeros(B, device=device)\n    \n    # Compute room center from floor polygon\n    poly = np.array(floor_polygons)\n    room_center = torch.tensor([poly[:, 0].mean(), poly[:, 1].mean()], device=device)\n    \n    for b in range(B):\n        # Get valid furniture positions and sizes\n        valid_mask = ~is_empty[b]\n        valid_positions = positions[b][valid_mask]  # (num_valid, 3)\n        valid_sizes = sizes[b][valid_mask]  # (num_valid, 3)\n        \n        if valid_positions.shape[0] == 0:\n            # No furniture - entire room is open and central\n            rewards[b] = 1.0\n            continue\n        \n        # Find the centroid of free space (inverse of furniture centroid)\n        furniture_xz = valid_positions[:, [0, 2]]  # (num_valid, 2)\n        furniture_centroid = furniture_xz.mean(dim=0)  # (2,)\n        \n        # The free space center is on the opposite side of furniture cluster\n        # Estimate as: room_center + (room_center - furniture_centroid)\n        free_space_center = 2 * room_center - furniture_centroid\n        \n        # Measure how close free space center is to room center\n        distance_to_center = torch.norm(free_space_center - room_center)\n        \n        # Also check if furniture is pushed to perimeter (good for centrality)\n        furniture_to_center_dist = torch.norm(furniture_centroid - room_center)\n        \n        # Reward: free space should be near center, furniture should be far from center\n        # Use exponential decay for distance\n        centrality_score = torch.exp(-distance_to_center) * (1.0 + 0.5 * torch.tanh(furniture_to_center_dist - 1.0))\n        \n        rewards[b] = torch.clamp(centrality_score, 0.0, 1.5)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Test function for workout space centrality reward.\n    \'\'\'\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions["create_scene_for_testing"]["function"]\n    \n    # Scene 1: Furniture pushed to one side - central open space (should get high reward)\n    num_objects_1 = 3\n    class_label_indices_1 = [8, 12, 20]\n    translations_1 = [(-2.5, 0.5, -2.0), (-2.5, 0.3, -0.5), (-2.5, 1.0, 0.5)]\n    sizes_1 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Furniture in center - open space in corners (should get lower reward)\n    num_objects_2 = 3\n    class_label_indices_2 = [8, 12, 20]\n    translations_2 = [(0.0, 0.5, 0.0), (0.5, 0.3, 0.5), (-0.5, 1.0, -0.5)]\n    sizes_2 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5)]\n    orientations_2 = [(1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No furniture (should get maximum reward)\n    num_objects_3 = 0\n    class_label_indices_3 = []\n    translations_3 = []\n    sizes_3 = []\n    orientations_3 = []\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes[\'room_type\'] = room_type\n    parsed_scenes[\'device\'] = scene_1[\'device\']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print("Rewards:", rewards)\n    print("Scene 1 (furniture on side, central open) reward:", rewards[0].item())\n    print("Scene 2 (furniture in center) reward:", rewards[1].item())\n    print("Scene 3 (no furniture) reward:", rewards[2].item())\n    \n    # assert rewards.shape[0] == 3, f"Expected 3 rewards, got {rewards.shape[0]}"\n    # assert rewards[0] > rewards[1], f"Furniture on side (reward={rewards[0].item():.4f}) should have higher reward than furniture in center (reward={rewards[1].item():.4f})"\n    # assert rewards[2] >= rewards[0], f"No furniture (reward={rewards[2].item():.4f}) should have highest reward"\n    # assert rewards[2] == 1.0, f"No furniture should have reward 1.0, got {rewards[2].item():.4f}"\n    # assert rewards.max() <= 1.5, f"Rewards should be capped at 1.5, got {rewards.max().item():.4f}"\n    \n    print("All tests passed!")', 'success_threshold': 0.7}, {'id': 'R4', 'constraint_id': 'C4', 'name': 'furniture_wall_proximity_reward', 'code': 'import torch\nimport numpy as np\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Reward for furniture wall proximity - encourages furniture near walls.\n    Measures average minimum distance from each furniture to nearest wall.\n    \n    Input:\n        - parsed_scenes: dict with scene data\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor vertices\n        - **kwargs: additional arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,) - higher for furniture closer to walls\n    \'\'\'\n    positions = parsed_scenes[\'positions\']  # (B, N, 3)\n    sizes = parsed_scenes[\'sizes\']  # (B, N, 3)\n    is_empty = parsed_scenes[\'is_empty\']  # (B, N)\n    orientations = parsed_scenes[\'orientations\']  # (B, N, 2)\n    device = parsed_scenes[\'device\']\n    \n    B, N, _ = positions.shape\n    rewards = torch.zeros(B, device=device)\n    \n    utility_functions = get_all_utility_functions()\n    find_closest_wall = utility_functions["find_closest_wall_to_object"]["function"]\n    \n    for b in range(B):\n        # Get valid furniture\n        valid_mask = ~is_empty[b]\n        valid_indices = torch.where(valid_mask)[0]\n        \n        if len(valid_indices) == 0:\n            # No furniture\n            rewards[b] = 0.0\n            continue\n        \n        distances_to_wall = []\n        \n        for idx in valid_indices:\n            pos = positions[b, idx:idx+1]  # (1, 3)\n            size = sizes[b, idx:idx+1]  # (1, 3)\n            orient = orientations[b, idx:idx+1]  # (1, 2)\n            \n            # Find distance to closest wall\n            try:\n                _, distance = find_closest_wall(pos, orient, size, floor_polygons, **kwargs)\n                distances_to_wall.append(distance)\n            except:\n                # Fallback: compute distance to boundary edges\n                poly = torch.tensor(floor_polygons, device=device, dtype=torch.float32)\n                x, z = pos[0, 0], pos[0, 2]\n                \n                # Distance to each edge\n                edge_dists = []\n                for i in range(len(floor_polygons)):\n                    p1 = poly[i]\n                    p2 = poly[(i+1) % len(floor_polygons)]\n                    \n                    # Point to line segment distance\n                    v = p2 - p1\n                    w = torch.tensor([x, z], device=device) - p1\n                    c1 = torch.dot(w, v)\n                    c2 = torch.dot(v, v)\n                    \n                    if c2 == 0:\n                        dist = torch.norm(w)\n                    else:\n                        t = torch.clamp(c1 / c2, 0, 1)\n                        proj = p1 + t * v\n                        dist = torch.norm(torch.tensor([x, z], device=device) - proj)\n                    \n                    edge_dists.append(dist)\n                \n                min_dist = min(edge_dists)\n                distances_to_wall.append(min_dist)\n        \n        # Average distance to walls\n        if len(distances_to_wall) > 0:\n            if isinstance(distances_to_wall[0], torch.Tensor):\n                avg_distance = torch.stack(distances_to_wall).mean()\n            else:\n                avg_distance = torch.tensor(np.mean(distances_to_wall), device=device)\n            \n            # Transform to reward: closer to wall = higher reward\n            # Use exponential decay with 1m reference distance\n            avg_distance_capped = torch.clamp(avg_distance, 0, 3.0)\n            rewards[b] = torch.exp(-avg_distance_capped)\n        else:\n            rewards[b] = 0.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Test function for furniture wall proximity reward.\n    \'\'\'\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions["create_scene_for_testing"]["function"]\n    \n    # Scene 1: Furniture close to walls (should get high reward)\n    num_objects_1 = 3\n    class_label_indices_1 = [8, 12, 20]\n    # Assuming floor polygon is roughly [-3, 3] x [-3, 3]\n    translations_1 = [(-2.5, 0.5, -2.5), (-2.5, 0.3, 2.0), (2.0, 1.0, -2.5)]\n    sizes_1 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Furniture in center of room (should get lower reward)\n    num_objects_2 = 3\n    class_label_indices_2 = [8, 12, 20]\n    translations_2 = [(0.0, 0.5, 0.0), (0.5, 0.3, 0.5), (-0.5, 1.0, -0.5)]\n    sizes_2 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5)]\n    orientations_2 = [(1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Mixed placement\n    num_objects_3 = 2\n    class_label_indices_3 = [8, 12]\n    translations_3 = [(-2.5, 0.5, 0.0), (0.0, 0.3, 0.0)]\n    sizes_3 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes[\'room_type\'] = room_type\n    parsed_scenes[\'device\'] = scene_1[\'device\']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print("Rewards:", rewards)\n    print("Scene 1 (furniture near walls) reward:", rewards[0].item())\n    print("Scene 2 (furniture in center) reward:", rewards[1].item())\n    print("Scene 3 (mixed placement) reward:", rewards[2].item())\n    \n    # assert rewards.shape[0] == 3, f"Expected 3 rewards, got {rewards.shape[0]}"\n    # assert rewards[0] > rewards[1], f"Furniture near walls (reward={rewards[0].item():.4f}) should have higher reward than furniture in center (reward={rewards[1].item():.4f})"\n    # assert rewards[0] > 0.5, f"Furniture near walls should have reward > 0.5, got {rewards[0].item():.4f}"\n    # assert rewards[1] < 0.5, f"Furniture in center should have reward < 0.5, got {rewards[1].item():.4f}"\n    # assert rewards[2] > rewards[1] and rewards[2] < rewards[0], f"Mixed placement reward ({rewards[2].item():.4f}) should be between center ({rewards[1].item():.4f}) and walls ({rewards[0].item():.4f})"\n    \n    print("All tests passed!")', 'success_threshold': 0.6}, {'id': 'R5', 'constraint_id': 'C5', 'name': 'minimum_workout_clearance_reward', 'code': 'import torch\nimport numpy as np\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Reward for minimum workout clearance - ensures workout area has sufficient clearance.\n    Checks vertical clearance (no low hanging objects) and horizontal clearance (wide paths).\n    \n    Input:\n        - parsed_scenes: dict with scene data\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor vertices\n        - **kwargs: additional arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,) - higher for better clearance\n    \'\'\'\n    positions = parsed_scenes[\'positions\']  # (B, N, 3)\n    sizes = parsed_scenes[\'sizes\']  # (B, N, 3)\n    is_empty = parsed_scenes[\'is_empty\']  # (B, N)\n    object_indices = parsed_scenes[\'object_indices\']  # (B, N)\n    device = parsed_scenes[\'device\']\n    \n    B, N, _ = positions.shape\n    rewards = torch.zeros(B, device=device)\n    \n    # Get pendant_lamp index from idx_to_labels\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    pendant_lamp_idx = labels_to_idx.get(\'pendant_lamp\', -1)\n    \n    # Minimum clearances for workout\n    min_vertical_clearance = 2.2  # meters (need headroom for jumping, arms up)\n    min_horizontal_clearance = 1.0  # meters (width of clear path)\n    \n    for b in range(B):\n        # Get valid furniture\n        valid_mask = ~is_empty[b]\n        valid_positions = positions[b][valid_mask]  # (num_valid, 3)\n        valid_sizes = sizes[b][valid_mask]  # (num_valid, 3)\n        valid_indices = object_indices[b][valid_mask]  # (num_valid,)\n        \n        if valid_positions.shape[0] == 0:\n            # No furniture - perfect clearance\n            rewards[b] = 1.0\n            continue\n        \n        # 1. Check vertical clearance (pendant lamps)\n        vertical_penalty = 0.0\n        if pendant_lamp_idx >= 0:\n            lamp_mask = valid_indices == pendant_lamp_idx\n            if lamp_mask.any():\n                lamp_positions = valid_positions[lamp_mask]\n                lamp_sizes = valid_sizes[lamp_mask]\n                \n                # Check if any pendant lamps are too low (below min_vertical_clearance)\n                lamp_bottom_y = lamp_positions[:, 1] - lamp_sizes[:, 1]  # bottom of lamp\n                low_lamps = lamp_bottom_y < min_vertical_clearance\n                \n                if low_lamps.any():\n                    # Penalize based on how low they are\n                    violations = min_vertical_clearance - lamp_bottom_y[low_lamps]\n                    vertical_penalty = violations.mean().item()\n        \n        # 2. Check horizontal clearance (minimum gap between furniture)\n        horizontal_score = 1.0\n        if valid_positions.shape[0] >= 2:\n            # Compute pairwise distances between furniture (on x-z plane)\n            xz_positions = valid_positions[:, [0, 2]]  # (num_valid, 2)\n            xz_sizes = valid_sizes[:, [0, 2]]  # (num_valid, 2)\n            \n            # For each pair, compute gap (distance between bounding boxes)\n            num_valid = xz_positions.shape[0]\n            min_gaps = []\n            \n            for i in range(num_valid):\n                for j in range(i+1, num_valid):\n                    pos_i = xz_positions[i]\n                    pos_j = xz_positions[j]\n                    size_i = xz_sizes[i]\n                    size_j = xz_sizes[j]\n                    \n                    # Center-to-center distance\n                    center_dist = torch.norm(pos_i - pos_j)\n                    \n                    # Sum of half-extents\n                    sum_extents = (size_i + size_j).norm()\n                    \n                    # Gap between objects (approximation)\n                    gap = center_dist - sum_extents\n                    min_gaps.append(gap)\n            \n            if len(min_gaps) > 0:\n                min_gap = min(min_gaps)\n                \n                # Score based on minimum gap\n                if min_gap < 0:\n                    # Objects overlapping (handled by penetration constraint)\n                    horizontal_score = 0.5\n                elif min_gap < min_horizontal_clearance:\n                    # Gap too narrow\n                    horizontal_score = 0.5 + 0.5 * (min_gap / min_horizontal_clearance)\n                else:\n                    # Good clearance\n                    horizontal_score = 1.0\n        \n        # 3. Combine vertical and horizontal scores\n        vertical_score = max(0.0, 1.0 - vertical_penalty / 1.0)  # Normalize penalty by 1m\n        \n        # Overall reward\n        rewards[b] = 0.5 * vertical_score + 0.5 * horizontal_score\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Test function for minimum workout clearance reward.\n    \'\'\'\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions["create_scene_for_testing"]["function"]\n    \n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    pendant_lamp_idx = labels_to_idx.get(\'pendant_lamp\', 13)\n    \n    # Scene 1: Good clearance - no low lamps, wide gaps (should get high reward)\n    num_objects_1 = 3\n    class_label_indices_1 = [8, 12, 20]  # bed, nightstand, wardrobe\n    translations_1 = [(-2.0, 0.5, -2.0), (-2.0, 0.3, 0.0), (2.0, 1.0, -2.0)]\n    sizes_1 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Low pendant lamp (should get lower reward)\n    num_objects_2 = 4\n    class_label_indices_2 = [8, 12, 20, pendant_lamp_idx]\n    translations_2 = [(-2.0, 0.5, -2.0), (-2.0, 0.3, 0.0), (2.0, 1.0, -2.0), (0.0, 2.0, 0.0)]  # Lamp at y=2.0\n    sizes_2 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5), (0.2, 0.3, 0.2)]  # Lamp hangs down 0.3m\n    orientations_2 = [(1, 0), (1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Furniture too close together (should get lower reward)\n    num_objects_3 = 3\n    class_label_indices_3 = [8, 12, 20]\n    translations_3 = [(0.0, 0.5, 0.0), (0.8, 0.3, 0.0), (1.5, 1.0, 0.0)]  # Very close together\n    sizes_3 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3), (0.5, 1.0, 0.5)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes[\'room_type\'] = room_type\n    parsed_scenes[\'device\'] = scene_1[\'device\']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print("Rewards:", rewards)\n    print("Scene 1 (good clearance) reward:", rewards[0].item())\n    print("Scene 2 (low pendant lamp) reward:", rewards[1].item())\n    print("Scene 3 (furniture too close) reward:", rewards[2].item())\n    \n    # assert rewards.shape[0] == 3, f"Expected 3 rewards, got {rewards.shape[0]}"\n    # assert rewards[0] > rewards[1], f"Good clearance (reward={rewards[0].item():.4f}) should have higher reward than low lamp (reward={rewards[1].item():.4f})"\n    # assert rewards[0] > rewards[2], f"Good clearance (reward={rewards[0].item():.4f}) should have higher reward than close furniture (reward={rewards[2].item():.4f})"\n    # assert rewards[0] >= 0.8, f"Good clearance should have reward >= 0.8, got {rewards[0].item():.4f}"\n    # assert 0.0 <= rewards[1] <= 1.0, f"Reward should be in [0,1], got {rewards[1].item():.4f}"\n    # assert 0.0 <= rewards[2] <= 1.0, f"Reward should be in [0,1], got {rewards[2].item():.4f}"\n    \n    print("All tests passed!")', 'success_threshold': 0.75}]}
        Reward Statistics = 
    