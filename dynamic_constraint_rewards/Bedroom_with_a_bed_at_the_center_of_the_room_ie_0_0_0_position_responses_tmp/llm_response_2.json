{
  "rewards": [
    {
      "id": "R1",
      "constraint_id": "C1",
      "name": "bed_at_room_center",
      "code": "import torch\nimport math\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward function for bed positioned at room center (0, 0, 0).\n    \n    Input:\n        - parsed_scenes: dict with batched scene data\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string, Example: \"bedroom\" or \"livingroom\"\n        - floor_polygons: list of ordered floor polygon vertices\n        - **kwargs: additional keyword arguments\n\n    Output:\n        reward: torch.Tensor of shape (B,) - higher reward when bed is closer to center\n    '''\n    positions = parsed_scenes['positions']  # (B, N, 3)\n    object_indices = parsed_scenes['object_indices']  # (B, N)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    device = parsed_scenes['device']\n    \n    B, N, _ = positions.shape\n    \n    # Find bed class indices\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    bed_classes = []\n    for bed_type in ['double_bed', 'single_bed', 'kids_bed']:\n        if bed_type in labels_to_idx:\n            bed_classes.append(labels_to_idx[bed_type])\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Find bed objects in this scene\n        bed_mask = torch.zeros(N, dtype=torch.bool, device=device)\n        for bed_idx in bed_classes:\n            bed_mask |= (object_indices[b] == bed_idx)\n        bed_mask &= ~is_empty[b]  # Exclude empty slots\n        \n        if bed_mask.sum() == 0:\n            # No bed found - give large penalty\n            rewards[b] = -10.0\n            continue\n        \n        # Get all bed positions\n        bed_positions = positions[b][bed_mask]  # (num_beds, 3)\n        \n        # Calculate distance from center (0, 0, 0) for each bed\n        # We care about XZ distance primarily, but include Y for completeness\n        distances = torch.norm(bed_positions, dim=1)  # (num_beds,)\n        \n        # Use the minimum distance (closest bed to center)\n        min_distance = distances.min()\n        \n        # Reward function: exponential decay based on distance\n        # Perfect center (distance=0) gives reward=0\n        # Distance increases -> reward becomes more negative\n        # Tolerance threshold of 0.3m gives reward ~ -0.9\n        # Distance of 1m gives reward ~ -10\n        rewards[b] = -10.0 * (1.0 - torch.exp(-min_distance / 0.3))\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the bed_at_room_center reward function.\n    '''\n    from dynamic_constraint_rewards.utilities import get_all_utility_functions\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    double_bed_idx = labels_to_idx['double_bed']\n    nightstand_idx = labels_to_idx['nightstand']\n    wardrobe_idx = labels_to_idx['wardrobe']\n    \n    # Scene 1: Bed exactly at center (0, 0, 0) - should get high reward (close to 0)\n    num_objects_1 = 3\n    class_label_indices_1 = [double_bed_idx, nightstand_idx, wardrobe_idx]\n    translations_1 = [(0.0, 0.4, 0.0), (2.0, 0.3, 2.0), (-2.0, 0.5, -2.0)]\n    sizes_1 = [(1.0, 0.4, 1.0), (0.3, 0.3, 0.3), (0.5, 0.5, 0.8)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Bed at (0.2, 0.4, 0.15) - slightly off center, should get moderate reward\n    num_objects_2 = 2\n    class_label_indices_2 = [double_bed_idx, nightstand_idx]\n    translations_2 = [(0.2, 0.4, 0.15), (2.5, 0.3, 2.5)]\n    sizes_2 = [(1.0, 0.4, 1.0), (0.3, 0.3, 0.3)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Bed far from center at (3.0, 0.4, 3.0) - should get low reward (very negative)\n    num_objects_3 = 2\n    class_label_indices_3 = [double_bed_idx, wardrobe_idx]\n    translations_3 = [(3.0, 0.4, 3.0), (-2.0, 0.5, -1.0)]\n    sizes_3 = [(1.0, 0.4, 1.0), (0.5, 0.5, 0.8)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Scene 4: No bed in scene - should get large penalty\n    num_objects_4 = 2\n    class_label_indices_4 = [nightstand_idx, wardrobe_idx]\n    translations_4 = [(1.0, 0.3, 1.0), (-1.0, 0.5, -1.0)]\n    sizes_4 = [(0.3, 0.3, 0.3), (0.5, 0.5, 0.8)]\n    orientations_4 = [(1, 0), (1, 0)]\n    scene_4 = create_scene(room_type, num_objects_4, class_label_indices_4, translations_4, sizes_4, orientations_4)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k], scene_4[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(f\"Scene 1 (bed at center): {rewards[0].item():.4f}\")\n    print(f\"Scene 2 (bed slightly off): {rewards[1].item():.4f}\")\n    print(f\"Scene 3 (bed far away): {rewards[2].item():.4f}\")\n    print(f\"Scene 4 (no bed): {rewards[3].item():.4f}\")\n    \n    assert rewards.shape[0] == 4, f\"Expected 4 rewards, got {rewards.shape[0]}\"\n    \n    # Scene 1: Bed at center should have reward close to 0 (>-1.0)\n    assert rewards[0] > -1.0, f\"Scene 1 (bed at center) should have high reward, got {rewards[0].item()}\"\n    \n    # Scene 2: Slightly off center should have moderate negative reward\n    assert -3.0 < rewards[1] < -0.5, f\"Scene 2 (slightly off) should have moderate reward between -3.0 and -0.5, got {rewards[1].item()}\"\n    \n    # Scene 3: Far from center should have very negative reward\n    assert rewards[2] < -8.0, f\"Scene 3 (far away) should have very negative reward (<-8.0), got {rewards[2].item()}\"\n    \n    # Scene 4: No bed should have the worst penalty\n    assert rewards[3] == -10.0, f\"Scene 4 (no bed) should have penalty of -10.0, got {rewards[3].item()}\"\n    \n    # Scene 1 should be better than Scene 2\n    assert rewards[0] > rewards[1], f\"Scene 1 should be better than Scene 2\"\n    \n    # Scene 2 should be better than Scene 3\n    assert rewards[1] > rewards[2], f\"Scene 2 should be better than Scene 3\"\n    \n    print(\"All tests passed!\")",
      "success_threshold": -1.0
    },
    {
      "id": "R2",
      "constraint_id": "C2",
      "name": "bed_exists_in_scene",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward function for verifying at least one bed exists in the scene.\n    \n    Input:\n        - parsed_scenes: dict with batched scene data\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string, Example: \"bedroom\" or \"livingroom\"\n        - floor_polygons: list of ordered floor polygon vertices\n        - **kwargs: additional keyword arguments\n\n    Output:\n        reward: torch.Tensor of shape (B,) - 1.0 if bed exists, -1.0 if not\n    '''\n    object_indices = parsed_scenes['object_indices']  # (B, N)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    device = parsed_scenes['device']\n    \n    B, N = object_indices.shape\n    \n    # Find bed class indices\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    bed_classes = []\n    for bed_type in ['double_bed', 'single_bed', 'kids_bed']:\n        if bed_type in labels_to_idx:\n            bed_classes.append(labels_to_idx[bed_type])\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Check if any bed exists in this scene\n        has_bed = False\n        for bed_idx in bed_classes:\n            bed_mask = (object_indices[b] == bed_idx) & ~is_empty[b]\n            if bed_mask.any():\n                has_bed = True\n                break\n        \n        if has_bed:\n            rewards[b] = 1.0\n        else:\n            rewards[b] = -1.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the bed_exists_in_scene reward function.\n    '''\n    from dynamic_constraint_rewards.utilities import get_all_utility_functions\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    double_bed_idx = labels_to_idx['double_bed']\n    single_bed_idx = labels_to_idx['single_bed']\n    nightstand_idx = labels_to_idx['nightstand']\n    wardrobe_idx = labels_to_idx['wardrobe']\n    \n    # Scene 1: Has double_bed\n    num_objects_1 = 3\n    class_label_indices_1 = [double_bed_idx, nightstand_idx, wardrobe_idx]\n    translations_1 = [(0.0, 0.4, 0.0), (2.0, 0.3, 2.0), (-2.0, 0.5, -2.0)]\n    sizes_1 = [(1.0, 0.4, 1.0), (0.3, 0.3, 0.3), (0.5, 0.5, 0.8)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has single_bed\n    num_objects_2 = 2\n    class_label_indices_2 = [single_bed_idx, nightstand_idx]\n    translations_2 = [(1.5, 0.3, 1.5), (2.5, 0.3, 2.5)]\n    sizes_2 = [(0.8, 0.3, 0.9), (0.3, 0.3, 0.3)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No bed, only other furniture\n    num_objects_3 = 2\n    class_label_indices_3 = [nightstand_idx, wardrobe_idx]\n    translations_3 = [(1.0, 0.3, 1.0), (-1.0, 0.5, -1.0)]\n    sizes_3 = [(0.3, 0.3, 0.3), (0.5, 0.5, 0.8)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(f\"Scene 1 (has double_bed): {rewards[0].item()}\")\n    print(f\"Scene 2 (has single_bed): {rewards[1].item()}\")\n    print(f\"Scene 3 (no bed): {rewards[2].item()}\")\n    \n    assert rewards.shape[0] == 3, f\"Expected 3 rewards, got {rewards.shape[0]}\"\n    \n    # Scene 1: Has double_bed, should get reward 1.0\n    assert rewards[0] == 1.0, f\"Scene 1 (has double_bed) should have reward 1.0, got {rewards[0].item()}\"\n    \n    # Scene 2: Has single_bed, should get reward 1.0\n    assert rewards[1] == 1.0, f\"Scene 2 (has single_bed) should have reward 1.0, got {rewards[1].item()}\"\n    \n    # Scene 3: No bed, should get penalty -1.0\n    assert rewards[2] == -1.0, f\"Scene 3 (no bed) should have penalty -1.0, got {rewards[2].item()}\"\n    \n    print(\"All tests passed!\")",
      "success_threshold": 0.9
    }
  ]
}