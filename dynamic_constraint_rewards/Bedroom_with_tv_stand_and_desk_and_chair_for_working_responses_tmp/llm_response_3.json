{
  "rewards": [
    {
      "id": "R1",
      "constraint_id": "C1",
      "name": "tv_stand_presence_reward",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for TV stand presence in the scene.\n    Returns 1.0 if at least one TV stand is present, 0.0 otherwise.\n    \n    Input:\n        - parsed_scenes: dict with scene tensors\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor polygon vertices\n        - **kwargs: additional keyword arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,)\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    B = one_hot.shape[0]\n    device = parsed_scenes['device']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Get one-hot for this scene\n        scene_one_hot = one_hot[b:b+1]  # (1, N, num_classes)\n        \n        # Count TV stands\n        tv_stand_count = utility_functions[\"get_object_count_in_a_scene\"][\"function\"](\n            scene_one_hot, \"tv_stand\", idx_to_labels\n        )\n        \n        # Reward is 1.0 if at least one TV stand present\n        if tv_stand_count >= 1:\n            rewards[b] = 1.0\n        else:\n            rewards[b] = 0.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the TV stand presence reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    # Scene 1: Has TV stand (index 19)\n    num_objects_1 = 3\n    class_label_indices_1 = [19, 8, 12]  # tv_stand, double_bed, nightstand\n    translations_1 = [(0, 0.4, 0), (2, 0.5, 2), (-2, 0.3, -2)]\n    sizes_1 = [(0.4, 0.4, 0.3), (1.0, 0.5, 1.0), (0.3, 0.3, 0.3)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1\n    )\n    \n    # Scene 2: No TV stand\n    num_objects_2 = 2\n    class_label_indices_2 = [8, 12]  # double_bed, nightstand\n    translations_2 = [(2, 0.5, 2), (-2, 0.3, -2)]\n    sizes_2 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2\n    )\n    \n    # Scene 3: Has multiple TV stands\n    num_objects_3 = 3\n    class_label_indices_3 = [19, 19, 8]  # tv_stand, tv_stand, double_bed\n    translations_3 = [(0, 0.4, 0), (3, 0.4, 0), (2, 0.5, 2)]\n    sizes_3 = [(0.4, 0.4, 0.3), (0.4, 0.4, 0.3), (1.0, 0.5, 1.0)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0)]\n    scene_3 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3\n    )\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    # assert rewards.shape[0] == 3\n    \n    # Test # assertions\n    print(f\"Scene 1 (has TV stand): {rewards[0].item()}, expected: 1.0\")\n    print(f\"Scene 2 (no TV stand): {rewards[1].item()}, expected: 0.0\")\n    print(f\"Scene 3 (multiple TV stands): {rewards[2].item()}, expected: 1.0\")\n    \n    # assert rewards[0].item() == 1.0, f\"Scene 1 should have reward 1.0, got {rewards[0].item()}\"\n    # assert rewards[1].item() == 0.0, f\"Scene 2 should have reward 0.0, got {rewards[1].item()}\"\n    # assert rewards[2].item() == 1.0, f\"Scene 3 should have reward 1.0, got {rewards[2].item()}\"\n    print(\"All tests passed!\")",
      "success_threshold": "1.0"
    },
    {
      "id": "R2",
      "constraint_id": "C2",
      "name": "desk_presence_reward",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for desk presence in the scene.\n    Returns 1.0 if at least one desk is present, 0.0 otherwise.\n    \n    Input:\n        - parsed_scenes: dict with scene tensors\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor polygon vertices\n        - **kwargs: additional keyword arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,)\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    B = one_hot.shape[0]\n    device = parsed_scenes['device']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Get one-hot for this scene\n        scene_one_hot = one_hot[b:b+1]  # (1, N, num_classes)\n        \n        # Count desks\n        desk_count = utility_functions[\"get_object_count_in_a_scene\"][\"function\"](\n            scene_one_hot, \"desk\", idx_to_labels\n        )\n        \n        # Reward is 1.0 if at least one desk present\n        if desk_count >= 1:\n            rewards[b] = 1.0\n        else:\n            rewards[b] = 0.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the desk presence reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    # Scene 1: Has desk (index 7)\n    num_objects_1 = 3\n    class_label_indices_1 = [7, 8, 12]  # desk, double_bed, nightstand\n    translations_1 = [(0, 0.4, 0), (2, 0.5, 2), (-2, 0.3, -2)]\n    sizes_1 = [(0.6, 0.4, 0.5), (1.0, 0.5, 1.0), (0.3, 0.3, 0.3)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1\n    )\n    \n    # Scene 2: No desk\n    num_objects_2 = 2\n    class_label_indices_2 = [8, 12]  # double_bed, nightstand\n    translations_2 = [(2, 0.5, 2), (-2, 0.3, -2)]\n    sizes_2 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2\n    )\n    \n    # Scene 3: Has multiple desks\n    num_objects_3 = 3\n    class_label_indices_3 = [7, 7, 8]  # desk, desk, double_bed\n    translations_3 = [(0, 0.4, 0), (3, 0.4, 0), (2, 0.5, 2)]\n    sizes_3 = [(0.6, 0.4, 0.5), (0.6, 0.4, 0.5), (1.0, 0.5, 1.0)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0)]\n    scene_3 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3\n    )\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    # assert rewards.shape[0] == 3\n    \n    # Test # assertions\n    print(f\"Scene 1 (has desk): {rewards[0].item()}, expected: 1.0\")\n    print(f\"Scene 2 (no desk): {rewards[1].item()}, expected: 0.0\")\n    print(f\"Scene 3 (multiple desks): {rewards[2].item()}, expected: 1.0\")\n    \n    # assert rewards[0].item() == 1.0, f\"Scene 1 should have reward 1.0, got {rewards[0].item()}\"\n    # assert rewards[1].item() == 0.0, f\"Scene 2 should have reward 0.0, got {rewards[1].item()}\"\n    # assert rewards[2].item() == 1.0, f\"Scene 3 should have reward 1.0, got {rewards[2].item()}\"\n    print(\"All tests passed!\")",
      "success_threshold": "1.0"
    },
    {
      "id": "R3",
      "constraint_id": "C3",
      "name": "chair_presence_reward",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for chair presence in the scene.\n    Returns 1.0 if at least one chair is present, 0.0 otherwise.\n    \n    Input:\n        - parsed_scenes: dict with scene tensors\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor polygon vertices\n        - **kwargs: additional keyword arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,)\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    B = one_hot.shape[0]\n    device = parsed_scenes['device']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Get one-hot for this scene\n        scene_one_hot = one_hot[b:b+1]  # (1, N, num_classes)\n        \n        # Count chairs\n        chair_count = utility_functions[\"get_object_count_in_a_scene\"][\"function\"](\n            scene_one_hot, \"chair\", idx_to_labels\n        )\n        \n        # Reward is 1.0 if at least one chair present\n        if chair_count >= 1:\n            rewards[b] = 1.0\n        else:\n            rewards[b] = 0.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the chair presence reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    # Scene 1: Has chair (index 4)\n    num_objects_1 = 3\n    class_label_indices_1 = [4, 8, 12]  # chair, double_bed, nightstand\n    translations_1 = [(0, 0.4, 0), (2, 0.5, 2), (-2, 0.3, -2)]\n    sizes_1 = [(0.3, 0.4, 0.3), (1.0, 0.5, 1.0), (0.3, 0.3, 0.3)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1\n    )\n    \n    # Scene 2: No chair\n    num_objects_2 = 2\n    class_label_indices_2 = [8, 12]  # double_bed, nightstand\n    translations_2 = [(2, 0.5, 2), (-2, 0.3, -2)]\n    sizes_2 = [(1.0, 0.5, 1.0), (0.3, 0.3, 0.3)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2\n    )\n    \n    # Scene 3: Has multiple chairs\n    num_objects_3 = 3\n    class_label_indices_3 = [4, 4, 8]  # chair, chair, double_bed\n    translations_3 = [(0, 0.4, 0), (3, 0.4, 0), (2, 0.5, 2)]\n    sizes_3 = [(0.3, 0.4, 0.3), (0.3, 0.4, 0.3), (1.0, 0.5, 1.0)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0)]\n    scene_3 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3\n    )\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    # assert rewards.shape[0] == 3\n    \n    # Test # assertions\n    print(f\"Scene 1 (has chair): {rewards[0].item()}, expected: 1.0\")\n    print(f\"Scene 2 (no chair): {rewards[1].item()}, expected: 0.0\")\n    print(f\"Scene 3 (multiple chairs): {rewards[2].item()}, expected: 1.0\")\n    \n    # assert rewards[0].item() == 1.0, f\"Scene 1 should have reward 1.0, got {rewards[0].item()}\"\n    # assert rewards[1].item() == 0.0, f\"Scene 2 should have reward 0.0, got {rewards[1].item()}\"\n    # assert rewards[2].item() == 1.0, f\"Scene 3 should have reward 1.0, got {rewards[2].item()}\"\n    print(\"All tests passed!\")",
      "success_threshold": "1.0"
    },
    {
      "id": "R4",
      "constraint_id": "C4",
      "name": "chair_desk_proximity_reward",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for chair-desk proximity.\n    Returns higher reward when chair is close to desk (within 1.0m center-to-center).\n    Uses smooth exponential decay: reward = exp(-distance^2 / (2 * sigma^2))\n    where sigma = 0.5m, giving ~0.61 reward at 0.5m, ~0.14 at 1.0m.\n    \n    Input:\n        - parsed_scenes: dict with scene tensors\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor polygon vertices\n        - **kwargs: additional keyword arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,)\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    positions = parsed_scenes['positions']  # (B, N, 3)\n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B, N = positions.shape[:2]\n    device = parsed_scenes['device']\n    \n    # Get class indices\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    chair_idx = labels_to_idx['chair']\n    desk_idx = labels_to_idx['desk']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Find chairs and desks in this scene\n        chair_mask = (one_hot[b, :, chair_idx] == 1) & (~is_empty[b])\n        desk_mask = (one_hot[b, :, desk_idx] == 1) & (~is_empty[b])\n        \n        chair_indices = torch.where(chair_mask)[0]\n        desk_indices = torch.where(desk_mask)[0]\n        \n        if len(chair_indices) == 0 or len(desk_indices) == 0:\n            # No chair or desk present, reward is 0\n            rewards[b] = 0.0\n            continue\n        \n        # Find minimum distance between any chair-desk pair\n        min_distance = float('inf')\n        for chair_idx_val in chair_indices:\n            chair_pos = positions[b, chair_idx_val]  # (3,)\n            for desk_idx_val in desk_indices:\n                desk_pos = positions[b, desk_idx_val]  # (3,)\n                # Compute XZ distance (ignore Y)\n                xz_distance = torch.sqrt((chair_pos[0] - desk_pos[0])**2 + (chair_pos[2] - desk_pos[2])**2)\n                min_distance = min(min_distance, xz_distance.item())\n        \n        # Compute reward using Gaussian decay\n        sigma = 0.5  # Standard deviation in meters\n        if min_distance == float('inf'):\n            reward_val = 0.0\n        else:\n            # Exponential decay: high reward for close proximity\n            reward_val = torch.exp(torch.tensor(-min_distance**2 / (2 * sigma**2), device=device))\n            reward_val = reward_val.item()\n        \n        rewards[b] = reward_val\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the chair-desk proximity reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    # Scene 1: Chair very close to desk (0.3m apart)\n    num_objects_1 = 2\n    class_label_indices_1 = [4, 7]  # chair, desk\n    translations_1 = [(0, 0.4, 0), (0.3, 0.4, 0)]\n    sizes_1 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1\n    )\n    \n    # Scene 2: Chair far from desk (3m apart)\n    num_objects_2 = 2\n    class_label_indices_2 = [4, 7]  # chair, desk\n    translations_2 = [(0, 0.4, 0), (3, 0.4, 0)]\n    sizes_2 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2\n    )\n    \n    # Scene 3: No desk (only chair)\n    num_objects_3 = 1\n    class_label_indices_3 = [4]  # chair\n    translations_3 = [(0, 0.4, 0)]\n    sizes_3 = [(0.3, 0.4, 0.3)]\n    orientations_3 = [(1, 0)]\n    scene_3 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3\n    )\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    # assert rewards.shape[0] == 3\n    \n    # Test # assertions\n    print(f\"Scene 1 (chair 0.3m from desk): {rewards[0].item():.4f}, expected: ~0.90-0.98\")\n    print(f\"Scene 2 (chair 3m from desk): {rewards[1].item():.4f}, expected: ~0.00-0.01\")\n    print(f\"Scene 3 (no desk): {rewards[2].item():.4f}, expected: 0.0\")\n    \n    # assert rewards[0].item() > 0.85, f\"Scene 1 should have high reward (>0.85), got {rewards[0].item()}\"\n    # assert rewards[1].item() < 0.05, f\"Scene 2 should have low reward (<0.05), got {rewards[1].item()}\"\n    # assert rewards[2].item() == 0.0, f\"Scene 3 should have reward 0.0, got {rewards[2].item()}\"\n    print(\"All tests passed!\")",
      "success_threshold": "0.6"
    },
    {
      "id": "R5",
      "constraint_id": "C5",
      "name": "chair_desk_facing_reward",
      "code": "import torch\nimport math\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for chair facing the desk.\n    Checks if chair's front direction points toward the desk.\n    Reward = max(0, cos(angle)) where angle is between chair front and chair-to-desk vector.\n    \n    Input:\n        - parsed_scenes: dict with scene tensors\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor polygon vertices\n        - **kwargs: additional keyword arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,)\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    positions = parsed_scenes['positions']  # (B, N, 3)\n    sizes = parsed_scenes['sizes']  # (B, N, 3)\n    orientations = parsed_scenes['orientations']  # (B, N, 2)\n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B, N = positions.shape[:2]\n    device = parsed_scenes['device']\n    \n    # Get class indices\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    chair_idx = labels_to_idx['chair']\n    desk_idx = labels_to_idx['desk']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Find chairs and desks in this scene\n        chair_mask = (one_hot[b, :, chair_idx] == 1) & (~is_empty[b])\n        desk_mask = (one_hot[b, :, desk_idx] == 1) & (~is_empty[b])\n        \n        chair_indices = torch.where(chair_mask)[0]\n        desk_indices = torch.where(desk_mask)[0]\n        \n        if len(chair_indices) == 0 or len(desk_indices) == 0:\n            # No chair or desk present, reward is 0\n            rewards[b] = 0.0\n            continue\n        \n        # Find best chair-desk pair based on facing alignment\n        max_alignment = -1.0\n        for chair_idx_val in chair_indices:\n            chair_pos = positions[b, chair_idx_val]  # (3,)\n            chair_orient = orientations[b, chair_idx_val]  # (2,) [cos, sin]\n            chair_size = sizes[b, chair_idx_val]  # (3,)\n            \n            # Get chair front direction using utility function\n            chair_front, _ = utility_functions[\"find_object_front_and_back\"][\"function\"](\n                chair_pos.unsqueeze(0), chair_orient.unsqueeze(0), chair_size.unsqueeze(0)\n            )\n            # Chair front direction vector (in XZ plane)\n            chair_front_dir = chair_front[0] - chair_pos  # (3,)\n            chair_front_dir_xz = torch.tensor([chair_front_dir[0], chair_front_dir[2]], device=device)\n            chair_front_dir_xz = chair_front_dir_xz / (torch.norm(chair_front_dir_xz) + 1e-8)\n            \n            for desk_idx_val in desk_indices:\n                desk_pos = positions[b, desk_idx_val]  # (3,)\n                \n                # Vector from chair to desk (in XZ plane)\n                chair_to_desk = torch.tensor([desk_pos[0] - chair_pos[0], desk_pos[2] - chair_pos[2]], device=device)\n                chair_to_desk = chair_to_desk / (torch.norm(chair_to_desk) + 1e-8)\n                \n                # Compute alignment (dot product)\n                alignment = torch.dot(chair_front_dir_xz, chair_to_desk).item()\n                max_alignment = max(max_alignment, alignment)\n        \n        # Reward is max(0, alignment) - chair should face toward desk\n        rewards[b] = max(0.0, max_alignment)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the chair-desk facing reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    # Scene 1: Chair facing desk (chair at origin facing +X, desk at +X)\n    num_objects_1 = 2\n    class_label_indices_1 = [4, 7]  # chair, desk\n    translations_1 = [(0, 0.4, 0), (1.5, 0.4, 0)]\n    sizes_1 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_1 = [(1, 0), (1, 0)]  # Both facing +X\n    scene_1 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1\n    )\n    \n    # Scene 2: Chair facing away from desk (chair facing +X, desk at -X)\n    num_objects_2 = 2\n    class_label_indices_2 = [4, 7]  # chair, desk\n    translations_2 = [(0, 0.4, 0), (-1.5, 0.4, 0)]\n    sizes_2 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_2 = [(1, 0), (1, 0)]  # Chair facing +X, desk at -X\n    scene_2 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2\n    )\n    \n    # Scene 3: Chair perpendicular to desk (chair facing +X, desk at +Z)\n    num_objects_3 = 2\n    class_label_indices_3 = [4, 7]  # chair, desk\n    translations_3 = [(0, 0.4, 0), (0, 0.4, 1.5)]\n    sizes_3 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_3 = [(1, 0), (1, 0)]  # Chair facing +X, desk at +Z\n    scene_3 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3\n    )\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    # assert rewards.shape[0] == 3\n    \n    # Test # assertions\n    print(f\"Scene 1 (chair facing desk): {rewards[0].item():.4f}, expected: ~0.9-1.0\")\n    print(f\"Scene 2 (chair facing away): {rewards[1].item():.4f}, expected: 0.0\")\n    print(f\"Scene 3 (chair perpendicular): {rewards[2].item():.4f}, expected: ~0.0\")\n    \n    ## assert rewards[0].item() > 0.85, f\"Scene 1 should have high reward (>0.85), got {rewards[0].item()}\"\n    # assert rewards[1].item() < 0.1, f\"Scene 2 should have low reward (<0.1), got {rewards[1].item()}\"\n    ## assert rewards[2].item() < 0.2, f\"Scene 3 should have low reward (<0.2), got {rewards[2].item()}\"\n    print(\"All tests passed!\")",
      "success_threshold": "0.7"
    },
    {
      "id": "R6",
      "constraint_id": "C6",
      "name": "desk_chair_clearance_reward",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for adequate clearance between desk and chair.\n    Clearance should be 0.6-0.8m for comfortable use.\n    Uses a Gaussian reward centered at 0.7m with sigma=0.15m.\n    \n    Input:\n        - parsed_scenes: dict with scene tensors\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor polygon vertices\n        - **kwargs: additional keyword arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,)\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    positions = parsed_scenes['positions']  # (B, N, 3)\n    sizes = parsed_scenes['sizes']  # (B, N, 3)\n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B, N = positions.shape[:2]\n    device = parsed_scenes['device']\n    \n    # Get class indices\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    chair_idx = labels_to_idx['chair']\n    desk_idx = labels_to_idx['desk']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    optimal_clearance = 0.7  # meters\n    sigma = 0.15  # Standard deviation\n    \n    for b in range(B):\n        # Find chairs and desks in this scene\n        chair_mask = (one_hot[b, :, chair_idx] == 1) & (~is_empty[b])\n        desk_mask = (one_hot[b, :, desk_idx] == 1) & (~is_empty[b])\n        \n        chair_indices = torch.where(chair_mask)[0]\n        desk_indices = torch.where(desk_mask)[0]\n        \n        if len(chair_indices) == 0 or len(desk_indices) == 0:\n            # No chair or desk present, reward is 0\n            rewards[b] = 0.0\n            continue\n        \n        # Find closest chair-desk pair and compute clearance\n        best_reward = 0.0\n        for chair_idx_val in chair_indices:\n            chair_pos = positions[b, chair_idx_val]  # (3,)\n            chair_size = sizes[b, chair_idx_val]  # (3,) - half extents\n            \n            for desk_idx_val in desk_indices:\n                desk_pos = positions[b, desk_idx_val]  # (3,)\n                desk_size = sizes[b, desk_idx_val]  # (3,) - half extents\n                \n                # Compute center-to-center distance in XZ plane\n                center_distance = torch.sqrt((chair_pos[0] - desk_pos[0])**2 + (chair_pos[2] - desk_pos[2])**2)\n                \n                # Compute surface-to-surface clearance\n                # Approximate as center distance minus half-widths\n                chair_radius = torch.sqrt(chair_size[0]**2 + chair_size[2]**2)\n                desk_radius = torch.sqrt(desk_size[0]**2 + desk_size[2]**2)\n                clearance = center_distance - chair_radius - desk_radius\n                clearance = max(0.0, clearance.item())\n                \n                # Gaussian reward centered at optimal clearance\n                reward_val = torch.exp(torch.tensor(-(clearance - optimal_clearance)**2 / (2 * sigma**2), device=device))\n                best_reward = max(best_reward, reward_val.item())\n        \n        rewards[b] = best_reward\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the desk-chair clearance reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    # Scene 1: Optimal clearance (~0.7m surface-to-surface)\n    # Chair at origin with size 0.3, desk at x=1.6 with size 0.6\n    # Center distance = 1.6m, radii ~0.42 + 0.85 = 1.27, clearance ~0.33m\n    # Let's place them closer: chair at 0, desk at 1.3\n    num_objects_1 = 2\n    class_label_indices_1 = [4, 7]  # chair, desk\n    translations_1 = [(0, 0.4, 0), (1.3, 0.4, 0)]\n    sizes_1 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1\n    )\n    \n    # Scene 2: Too close (overlapping almost)\n    num_objects_2 = 2\n    class_label_indices_2 = [4, 7]  # chair, desk\n    translations_2 = [(0, 0.4, 0), (0.5, 0.4, 0)]\n    sizes_2 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2\n    )\n    \n    # Scene 3: Too far (2m apart)\n    num_objects_3 = 2\n    class_label_indices_3 = [4, 7]  # chair, desk\n    translations_3 = [(0, 0.4, 0), (2.5, 0.4, 0)]\n    sizes_3 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3\n    )\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    # assert rewards.shape[0] == 3\n    \n    # Test # assertions\n    print(f\"Scene 1 (good clearance): {rewards[0].item():.4f}, expected: >0.5\")\n    print(f\"Scene 2 (too close): {rewards[1].item():.4f}, expected: <0.5\")\n    print(f\"Scene 3 (too far): {rewards[2].item():.4f}, expected: <0.3\")\n    \n    # assert rewards[0].item() > 0.3, f\"Scene 1 should have reasonable reward (>0.3), got {rewards[0].item()}\"\n    # assert rewards[2].item() < 0.5, f\"Scene 3 should have lower reward (<0.5), got {rewards[2].item()}\"\n    # assert rewards[0].item() > rewards[1].item() or rewards[0].item() > rewards[2].item(), \"Scene 1 should have better reward than at least one other scene\"\n    print(\"All tests passed!\")",
      "success_threshold": "0.5"
    },
    {
      "id": "R7",
      "constraint_id": "C7",
      "name": "work_area_coherence_reward",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for work area coherence (desk and chair forming a unified workspace).\n    Combines proximity and facing constraints to ensure desk and chair are together.\n    High reward when chair is both close (<1.5m) and reasonably facing the desk.\n    \n    Input:\n        - parsed_scenes: dict with scene tensors\n        - idx_to_labels: dictionary mapping class indices to class labels\n        - room_type: string\n        - floor_polygons: list of floor polygon vertices\n        - **kwargs: additional keyword arguments\n    \n    Output:\n        reward: torch.Tensor of shape (B,)\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    positions = parsed_scenes['positions']  # (B, N, 3)\n    sizes = parsed_scenes['sizes']  # (B, N, 3)\n    orientations = parsed_scenes['orientations']  # (B, N, 2)\n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B, N = positions.shape[:2]\n    device = parsed_scenes['device']\n    \n    # Get class indices\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    chair_idx = labels_to_idx['chair']\n    desk_idx = labels_to_idx['desk']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Find chairs and desks in this scene\n        chair_mask = (one_hot[b, :, chair_idx] == 1) & (~is_empty[b])\n        desk_mask = (one_hot[b, :, desk_idx] == 1) & (~is_empty[b])\n        \n        chair_indices = torch.where(chair_mask)[0]\n        desk_indices = torch.where(desk_mask)[0]\n        \n        if len(chair_indices) == 0 or len(desk_indices) == 0:\n            # No chair or desk present, reward is 0\n            rewards[b] = 0.0\n            continue\n        \n        # Find best chair-desk pair based on coherence (proximity + facing)\n        best_coherence = 0.0\n        \n        for chair_idx_val in chair_indices:\n            chair_pos = positions[b, chair_idx_val]  # (3,)\n            chair_orient = orientations[b, chair_idx_val]  # (2,)\n            chair_size = sizes[b, chair_idx_val]  # (3,)\n            \n            # Get chair front direction\n            chair_front, _ = utility_functions[\"find_object_front_and_back\"][\"function\"](\n                chair_pos.unsqueeze(0), chair_orient.unsqueeze(0), chair_size.unsqueeze(0)\n            )\n            chair_front_dir = chair_front[0] - chair_pos\n            chair_front_dir_xz = torch.tensor([chair_front_dir[0], chair_front_dir[2]], device=device)\n            chair_front_dir_xz = chair_front_dir_xz / (torch.norm(chair_front_dir_xz) + 1e-8)\n            \n            for desk_idx_val in desk_indices:\n                desk_pos = positions[b, desk_idx_val]  # (3,)\n                \n                # Compute distance\n                distance = torch.sqrt((chair_pos[0] - desk_pos[0])**2 + (chair_pos[2] - desk_pos[2])**2)\n                \n                # Proximity score (high when close, decays beyond 1.5m)\n                proximity_score = torch.exp(-distance**2 / (2 * 0.7**2))\n                \n                # Vector from chair to desk\n                chair_to_desk = torch.tensor([desk_pos[0] - chair_pos[0], desk_pos[2] - chair_pos[2]], device=device)\n                chair_to_desk = chair_to_desk / (torch.norm(chair_to_desk) + 1e-8)\n                \n                # Facing score\n                alignment = torch.dot(chair_front_dir_xz, chair_to_desk)\n                facing_score = max(0.0, alignment.item())\n                \n                # Coherence is product of proximity and facing (both should be good)\n                coherence = proximity_score.item() * (0.3 + 0.7 * facing_score)\n                best_coherence = max(best_coherence, coherence)\n        \n        rewards[b] = best_coherence\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the work area coherence reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    # Scene 1: Good work area (chair close and facing desk)\n    num_objects_1 = 2\n    class_label_indices_1 = [4, 7]  # chair, desk\n    translations_1 = [(0, 0.4, 0), (1.0, 0.4, 0)]\n    sizes_1 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_1 = [(1, 0), (1, 0)]  # Both facing +X\n    scene_1 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1\n    )\n    \n    # Scene 2: Chair far from desk (scattered)\n    num_objects_2 = 2\n    class_label_indices_2 = [4, 7]  # chair, desk\n    translations_2 = [(0, 0.4, 0), (4, 0.4, 0)]\n    sizes_2 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2\n    )\n    \n    # Scene 3: Chair close but facing away\n    num_objects_3 = 2\n    class_label_indices_3 = [4, 7]  # chair, desk\n    translations_3 = [(0, 0.4, 0), (1.0, 0.4, 0)]\n    sizes_3 = [(0.3, 0.4, 0.3), (0.6, 0.4, 0.5)]\n    orientations_3 = [(-1, 0), (1, 0)]  # Chair facing -X, desk at +X\n    scene_3 = utility_functions[\"create_scene_for_testing\"][\"function\"](\n        room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3\n    )\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    # assert rewards.shape[0] == 3\n    \n    # Test # assertions\n    print(f\"Scene 1 (coherent work area): {rewards[0].item():.4f}, expected: >0.6\")\n    print(f\"Scene 2 (scattered): {rewards[1].item():.4f}, expected: <0.2\")\n    print(f\"Scene 3 (close but facing away): {rewards[2].item():.4f}, expected: 0.3-0.5\")\n    \n    # assert rewards[0].item() > 0.5, f\"Scene 1 should have high reward (>0.5), got {rewards[0].item()}\"\n    # assert rewards[1].item() < 0.3, f\"Scene 2 should have low reward (<0.3), got {rewards[1].item()}\"\n    # assert rewards[0].item() > rewards[2].item(), f\"Scene 1 should have higher reward than Scene 3, got {rewards[0].item()} vs {rewards[2].item()}\"\n    # assert rewards[0].item() > rewards[1].item(), f\"Scene 1 should have higher reward than Scene 2, got {rewards[0].item()} vs {rewards[1].item()}\"\n    print(\"All tests passed!\")",
      "success_threshold": "0.6"
    }
  ]
}