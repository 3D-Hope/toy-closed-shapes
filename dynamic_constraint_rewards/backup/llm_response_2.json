{
    "rewards": [
        {
            "id": "R1",
            "constraint_id": "C1",
            "name": "minimum_seating_capacity",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for having at least 10 seating positions in the scene.\n    Seating furniture includes: dining_chair, stool, armchair, lounge_chair, chinese_chair\n    \n    Returns:\n        reward: (B,) tensor - 0 if >= 10 seats, negative penalty otherwise\n    '''\n    utility_functions = get_all_utility_functions()\n    get_object_count = utility_functions[\"get_object_count_in_a_scene\"][\"function\"]\n    \n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    B = one_hot.shape[0]\n    device = parsed_scenes['device']\n    \n    # Define seating furniture types\n    seating_types = ['dining_chair', 'stool', 'armchair', 'lounge_chair', 'chinese_chair']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Count total seating capacity\n        total_seats = 0\n        for seat_type in seating_types:\n            count = get_object_count(one_hot[b:b+1], seat_type, idx_to_labels)\n            total_seats += count\n        \n        # Reward: 0 if >= 10 seats, else penalty proportional to shortfall\n        if total_seats >= 10:\n            rewards[b] = 0.0\n        else:\n            rewards[b] = -(10 - total_seats) * 1.0  # -1.0 per missing seat\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the minimum_seating_capacity reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    # Get indices for furniture\n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    chair_idx = labels_to_idx.get('dining_chair', 10)\n    stool_idx = labels_to_idx.get('stool', 20)\n    table_idx = labels_to_idx.get('dining_table', 11)\n    \n    # Scene 1: 10 chairs (exactly meets requirement)\n    num_objects_1 = 10\n    class_label_indices_1 = [chair_idx] * 10\n    translations_1 = [(i, 0.4, 0) for i in range(10)]\n    sizes_1 = [(0.3, 0.4, 0.3)] * 10\n    orientations_1 = [(1, 0)] * 10\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: 5 chairs + 6 stools = 11 (exceeds requirement)\n    num_objects_2 = 11\n    class_label_indices_2 = [chair_idx] * 5 + [stool_idx] * 6\n    translations_2 = [(i, 0.4, 0) for i in range(11)]\n    sizes_2 = [(0.3, 0.4, 0.3)] * 11\n    orientations_2 = [(1, 0)] * 11\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Only 6 chairs (below requirement)\n    num_objects_3 = 6\n    class_label_indices_3 = [chair_idx] * 6\n    translations_3 = [(i, 0.4, 0) for i in range(6)]\n    sizes_3 = [(0.3, 0.4, 0.3)] * 6\n    orientations_3 = [(1, 0)] * 6\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    # Stack scenes\n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    assert rewards.shape[0] == 3\n    \n    # Test assertions\n    assert rewards[0] >= -0.1, \"Scene 1 should have 0 penalty (10 chairs)\"\n    assert rewards[1] >= -0.1, \"Scene 2 should have 0 penalty (11 seats)\"\n    assert rewards[2] < -3.5, \"Scene 3 should have penalty (only 6 chairs)\"\n    print(\"All tests passed for minimum_seating_capacity!\")",
            "success_threshold": -0.5
        },
        {
            "id": "R2",
            "constraint_id": "C2",
            "name": "has_teaching_workspace",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for having at least one desk or console_table for teacher workspace.\n    \n    Returns:\n        reward: (B,) tensor - 0 if has teaching workspace, -5.0 otherwise\n    '''\n    utility_functions = get_all_utility_functions()\n    get_object_count = utility_functions[\"get_object_count_in_a_scene\"][\"function\"]\n    \n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    B = one_hot.shape[0]\n    device = parsed_scenes['device']\n    \n    # Teaching workspace furniture\n    workspace_types = ['desk', 'console_table']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        has_workspace = False\n        for workspace_type in workspace_types:\n            count = get_object_count(one_hot[b:b+1], workspace_type, idx_to_labels)\n            if count > 0:\n                has_workspace = True\n                break\n        \n        if has_workspace:\n            rewards[b] = 0.0\n        else:\n            rewards[b] = -5.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the has_teaching_workspace reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    desk_idx = labels_to_idx.get('desk', 7)\n    console_idx = labels_to_idx.get('console_table', 7)\n    chair_idx = labels_to_idx.get('dining_chair', 10)\n    \n    # Scene 1: Has desk\n    num_objects_1 = 2\n    class_label_indices_1 = [desk_idx, chair_idx]\n    translations_1 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_1 = [(0.6, 0.4, 0.4), (0.3, 0.4, 0.3)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has console_table\n    num_objects_2 = 2\n    class_label_indices_2 = [console_idx, chair_idx]\n    translations_2 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_2 = [(0.6, 0.4, 0.3), (0.3, 0.4, 0.3)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No desk or console_table\n    num_objects_3 = 2\n    class_label_indices_3 = [chair_idx, chair_idx]\n    translations_3 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_3 = [(0.3, 0.4, 0.3), (0.3, 0.4, 0.3)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    assert rewards.shape[0] == 3\n    \n    assert rewards[0] >= -0.1, \"Scene 1 should have 0 penalty (has desk)\"\n    assert rewards[1] >= -0.1, \"Scene 2 should have 0 penalty (has console_table)\"\n    assert rewards[2] <= -4.9, \"Scene 3 should have penalty (no workspace)\"\n    print(\"All tests passed for has_teaching_workspace!\")",
            "success_threshold": -0.5
        },
        {
            "id": "R3",
            "constraint_id": "C3",
            "name": "organized_seating_arrangement",
            "code": "import torch\nimport math\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for organized seating arrangement - chairs should face similar directions\n    and be spatially clustered.\n    \n    Returns:\n        reward: (B,) tensor - negative penalty for angular deviation and spatial scatter\n    '''\n    utility_functions = get_all_utility_functions()\n    compute_angle = utility_functions[\"compute_angle_between_objects\"][\"function\"]\n    distance_2d = utility_functions[\"distance_2d\"][\"function\"]\n    \n    positions = parsed_scenes['positions']  # (B, N, 3)\n    orientations = parsed_scenes['orientations']  # (B, N, 2)\n    object_indices = parsed_scenes['object_indices']  # (B, N)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B, N = positions.shape[0], positions.shape[1]\n    device = parsed_scenes['device']\n    \n    # Seating furniture\n    seating_types = ['dining_chair', 'stool', 'armchair', 'lounge_chair', 'chinese_chair']\n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    seating_indices = [labels_to_idx.get(st, -1) for st in seating_types if labels_to_idx.get(st, -1) != -1]\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Find all seating objects\n        seat_mask = torch.zeros(N, dtype=torch.bool, device=device)\n        for idx in seating_indices:\n            seat_mask |= (object_indices[b] == idx)\n        seat_mask &= ~is_empty[b]\n        \n        seat_positions = positions[b][seat_mask]  # (num_seats, 3)\n        seat_orientations = orientations[b][seat_mask]  # (num_seats, 2)\n        num_seats = seat_mask.sum().item()\n        \n        if num_seats < 2:\n            rewards[b] = 0.0\n            continue\n        \n        # Calculate angular alignment - all chairs should face similar direction\n        total_angle_dev = 0.0\n        count = 0\n        for i in range(num_seats):\n            for j in range(i+1, num_seats):\n                angle_rad = compute_angle(seat_orientations[i], seat_orientations[j])\n                angle_deg = abs(angle_rad.item()) * 180.0 / math.pi\n                # Normalize to [0, 90] (considering 180° symmetry)\n                angle_dev = min(angle_deg, 180 - angle_deg)\n                total_angle_dev += angle_dev\n                count += 1\n        \n        avg_angle_dev = total_angle_dev / count if count > 0 else 0.0\n        \n        # Calculate spatial clustering - chairs should be close together\n        total_distance = 0.0\n        dist_count = 0\n        for i in range(num_seats):\n            for j in range(i+1, num_seats):\n                dist = distance_2d(seat_positions[i], seat_positions[j])\n                total_distance += dist.item()\n                dist_count += 1\n        \n        avg_distance = total_distance / dist_count if dist_count > 0 else 0.0\n        \n        # Penalty: higher for scattered placement and misaligned orientations\n        # Good classroom: avg_angle_dev < 15°, avg_distance < 3m\n        angle_penalty = max(0, (avg_angle_dev - 15.0) * 0.1)  # 0.1 per degree over 15°\n        distance_penalty = max(0, (avg_distance - 3.0) * 0.5)  # 0.5 per meter over 3m\n        \n        rewards[b] = -(angle_penalty + distance_penalty)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the organized_seating_arrangement reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    chair_idx = labels_to_idx.get('dining_chair', 10)\n    \n    # Scene 1: Well-organized (same direction, close together)\n    num_objects_1 = 6\n    class_label_indices_1 = [chair_idx] * 6\n    translations_1 = [(0, 0.4, 0), (1, 0.4, 0), (2, 0.4, 0), (0, 0.4, 1), (1, 0.4, 1), (2, 0.4, 1)]\n    sizes_1 = [(0.3, 0.4, 0.3)] * 6\n    orientations_1 = [(1, 0)] * 6  # All facing same direction\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Poorly organized (random directions, scattered)\n    num_objects_2 = 6\n    class_label_indices_2 = [chair_idx] * 6\n    translations_2 = [(0, 0.4, 0), (5, 0.4, 0), (10, 0.4, 0), (15, 0.4, 5), (20, 0.4, 10), (25, 0.4, 15)]\n    sizes_2 = [(0.3, 0.4, 0.3)] * 6\n    orientations_2 = [(1, 0), (0, 1), (-1, 0), (0, -1), (0.707, 0.707), (-0.707, 0.707)]  # Random directions\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Only 1 chair (no penalty)\n    num_objects_3 = 1\n    class_label_indices_3 = [chair_idx]\n    translations_3 = [(0, 0.4, 0)]\n    sizes_3 = [(0.3, 0.4, 0.3)]\n    orientations_3 = [(1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    assert rewards.shape[0] == 3\n    \n    assert rewards[0] >= -1.0, \"Scene 1 should have minimal penalty (organized)\"\n    assert rewards[1] <= -5.0, \"Scene 2 should have high penalty (disorganized)\"\n    assert rewards[2] >= -0.1, \"Scene 3 should have no penalty (only 1 chair)\"\n    print(\"All tests passed for organized_seating_arrangement!\")",
            "success_threshold": -2.0
        },
        {
            "id": "R4",
            "constraint_id": "C4",
            "name": "sufficient_student_workspace",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for having adequate work surfaces near seating.\n    Count tables/desks and verify they are within 1.5m of chairs.\n    \n    Returns:\n        reward: (B,) tensor - penalty for insufficient workspace coverage\n    '''\n    utility_functions = get_all_utility_functions()\n    distance_2d = utility_functions[\"distance_2d\"][\"function\"]\n    get_object_count = utility_functions[\"get_object_count_in_a_scene\"][\"function\"]\n    \n    positions = parsed_scenes['positions']  # (B, N, 3)\n    object_indices = parsed_scenes['object_indices']  # (B, N)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    one_hot = parsed_scenes['one_hot']  # (B, N, num_classes)\n    B, N = positions.shape[0], positions.shape[1]\n    device = parsed_scenes['device']\n    \n    # Workspace and seating furniture\n    workspace_types = ['dining_table', 'desk', 'console_table']\n    seating_types = ['dining_chair', 'stool', 'armchair', 'lounge_chair', 'chinese_chair']\n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    \n    workspace_indices = [labels_to_idx.get(wt, -1) for wt in workspace_types if labels_to_idx.get(wt, -1) != -1]\n    seating_indices = [labels_to_idx.get(st, -1) for st in seating_types if labels_to_idx.get(st, -1) != -1]\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        # Count workspaces\n        total_workspaces = 0\n        for wt in workspace_types:\n            total_workspaces += get_object_count(one_hot[b:b+1], wt, idx_to_labels)\n        \n        # Count seats\n        total_seats = 0\n        for st in seating_types:\n            total_seats += get_object_count(one_hot[b:b+1], st, idx_to_labels)\n        \n        if total_seats == 0:\n            rewards[b] = 0.0\n            continue\n        \n        # Check workspace availability\n        # Ideally: 1 workspace per 2-3 students (for group work)\n        expected_workspaces = max(1, total_seats // 3)\n        \n        if total_workspaces < expected_workspaces:\n            rewards[b] = -(expected_workspaces - total_workspaces) * 2.0\n        else:\n            # Now check proximity: are workspaces within 1.5m of seats?\n            workspace_mask = torch.zeros(N, dtype=torch.bool, device=device)\n            for idx in workspace_indices:\n                workspace_mask |= (object_indices[b] == idx)\n            workspace_mask &= ~is_empty[b]\n            \n            seat_mask = torch.zeros(N, dtype=torch.bool, device=device)\n            for idx in seating_indices:\n                seat_mask |= (object_indices[b] == idx)\n            seat_mask &= ~is_empty[b]\n            \n            workspace_positions = positions[b][workspace_mask]\n            seat_positions = positions[b][seat_mask]\n            \n            if workspace_positions.shape[0] > 0 and seat_positions.shape[0] > 0:\n                # Check if each workspace is near at least one seat\n                far_workspaces = 0\n                for wp in workspace_positions:\n                    min_dist = float('inf')\n                    for sp in seat_positions:\n                        dist = distance_2d(wp, sp).item()\n                        min_dist = min(min_dist, dist)\n                    if min_dist > 1.5:\n                        far_workspaces += 1\n                \n                rewards[b] = -far_workspaces * 1.0\n            else:\n                rewards[b] = 0.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the sufficient_student_workspace reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    chair_idx = labels_to_idx.get('dining_chair', 10)\n    table_idx = labels_to_idx.get('dining_table', 11)\n    desk_idx = labels_to_idx.get('desk', 7)\n    \n    # Scene 1: 6 chairs + 2 tables nearby (good)\n    num_objects_1 = 8\n    class_label_indices_1 = [chair_idx]*6 + [table_idx]*2\n    translations_1 = [(0, 0.4, 0), (1, 0.4, 0), (2, 0.4, 0), (0, 0.4, 1), (1, 0.4, 1), (2, 0.4, 1), (0.5, 0.4, 0.5), (1.5, 0.4, 0.5)]\n    sizes_1 = [(0.3, 0.4, 0.3)]*6 + [(0.8, 0.4, 0.5)]*2\n    orientations_1 = [(1, 0)]*8\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: 9 chairs but no tables (bad)\n    num_objects_2 = 9\n    class_label_indices_2 = [chair_idx]*9\n    translations_2 = [(i, 0.4, 0) for i in range(9)]\n    sizes_2 = [(0.3, 0.4, 0.3)]*9\n    orientations_2 = [(1, 0)]*9\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: 6 chairs + 1 desk nearby (okay)\n    num_objects_3 = 7\n    class_label_indices_3 = [chair_idx]*6 + [desk_idx]\n    translations_3 = [(0, 0.4, 0), (1, 0.4, 0), (2, 0.4, 0), (0, 0.4, 1), (1, 0.4, 1), (2, 0.4, 1), (1, 0.4, 0.5)]\n    sizes_3 = [(0.3, 0.4, 0.3)]*6 + [(0.8, 0.4, 0.5)]\n    orientations_3 = [(1, 0)]*7\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    assert rewards.shape[0] == 3\n    \n    assert rewards[0] >= -1.0, \"Scene 1 should have minimal penalty (good workspace)\"\n    assert rewards[1] <= -3.0, \"Scene 2 should have penalty (no tables)\"\n    assert rewards[2] >= -2.0, \"Scene 3 should have acceptable workspace\"\n    print(\"All tests passed for sufficient_student_workspace!\")",
            "success_threshold": -1.5
        },
        {
            "id": "R5",
            "constraint_id": "C5",
            "name": "chair_to_table_pairing",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for chair-table pairing - each chair should be within 1.0m of a table.\n    \n    Returns:\n        reward: (B,) tensor - penalty for unpaired chairs\n    '''\n    utility_functions = get_all_utility_functions()\n    distance_2d = utility_functions[\"distance_2d\"][\"function\"]\n    \n    positions = parsed_scenes['positions']\n    object_indices = parsed_scenes['object_indices']\n    is_empty = parsed_scenes['is_empty']\n    B, N = positions.shape[0], positions.shape[1]\n    device = parsed_scenes['device']\n    \n    workspace_types = ['dining_table', 'desk', 'console_table']\n    seating_types = ['dining_chair', 'stool', 'armchair', 'lounge_chair', 'chinese_chair']\n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    \n    workspace_indices = [labels_to_idx.get(wt, -1) for wt in workspace_types if labels_to_idx.get(wt, -1) != -1]\n    seating_indices = [labels_to_idx.get(st, -1) for st in seating_types if labels_to_idx.get(st, -1) != -1]\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        workspace_mask = torch.zeros(N, dtype=torch.bool, device=device)\n        for idx in workspace_indices:\n            workspace_mask |= (object_indices[b] == idx)\n        workspace_mask &= ~is_empty[b]\n        \n        seat_mask = torch.zeros(N, dtype=torch.bool, device=device)\n        for idx in seating_indices:\n            seat_mask |= (object_indices[b] == idx)\n        seat_mask &= ~is_empty[b]\n        \n        workspace_positions = positions[b][workspace_mask]\n        seat_positions = positions[b][seat_mask]\n        num_seats = seat_mask.sum().item()\n        \n        if num_seats == 0 or workspace_positions.shape[0] == 0:\n            rewards[b] = 0.0\n            continue\n        \n        unpaired_chairs = 0\n        for seat_pos in seat_positions:\n            min_dist = float('inf')\n            for workspace_pos in workspace_positions:\n                dist = distance_2d(seat_pos, workspace_pos).item()\n                min_dist = min(min_dist, dist)\n            \n            if min_dist > 1.0:\n                unpaired_chairs += 1\n        \n        rewards[b] = -unpaired_chairs * 1.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the chair_to_table_pairing reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    chair_idx = labels_to_idx.get('dining_chair', 10)\n    table_idx = labels_to_idx.get('dining_table', 11)\n    \n    # Scene 1: 4 chairs all within 1.0m of table (perfect pairing)\n    num_objects_1 = 5\n    class_label_indices_1 = [chair_idx, chair_idx, chair_idx, chair_idx, table_idx]\n    translations_1 = [(0, 0.4, 0), (1.5, 0.4, 0), (0, 0.4, 0.8), (1.5, 0.4, 0.8), (0.75, 0.4, 0.4)]\n    sizes_1 = [(0.3, 0.4, 0.3), (0.3, 0.4, 0.3), (0.3, 0.4, 0.3), (0.3, 0.4, 0.3), (0.8, 0.4, 0.5)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: 4 chairs, 2 far from table (partial pairing)\n    num_objects_2 = 5\n    class_label_indices_2 = [chair_idx, chair_idx, chair_idx, chair_idx, table_idx]\n    translations_2 = [(0, 0.4, 0), (1.5, 0.4, 0), (5, 0.4, 5), (6, 0.4, 5), (0.75, 0.4, 0.4)]\n    sizes_2 = [(0.3, 0.4, 0.3), (0.3, 0.4, 0.3), (0.3, 0.4, 0.3), (0.3, 0.4, 0.3), (0.8, 0.4, 0.5)]\n    orientations_2 = [(1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No tables (all chairs unpaired)\n    num_objects_3 = 3\n    class_label_indices_3 = [chair_idx, chair_idx, chair_idx]\n    translations_3 = [(0, 0.4, 0), (1, 0.4, 0), (2, 0.4, 0)]\n    sizes_3 = [(0.3, 0.4, 0.3), (0.3, 0.4, 0.3), (0.3, 0.4, 0.3)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    assert rewards.shape[0] == 3\n    \n    assert rewards[0] >= -0.1, \"Scene 1 should have no penalty (all chairs paired)\"\n    assert rewards[1] <= -1.5, \"Scene 2 should have penalty (2 chairs unpaired)\"\n    assert rewards[2] == 0.0, \"Scene 3 should have no penalty (no tables to pair with)\"\n    print(\"All tests passed for chair_to_table_pairing!\")",
            "success_threshold": -2.0
        },
        {
            "id": "R6",
            "constraint_id": "C6",
            "name": "adequate_lighting",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for having adequate lighting (1-2 light sources minimum).\n    \n    Returns:\n        reward: (B,) tensor - 0 if >= 1 light, negative penalty otherwise\n    '''\n    utility_functions = get_all_utility_functions()\n    get_object_count = utility_functions[\"get_object_count_in_a_scene\"][\"function\"]\n    \n    one_hot = parsed_scenes['one_hot']\n    B = one_hot.shape[0]\n    device = parsed_scenes['device']\n    \n    lighting_types = ['pendant_lamp', 'ceiling_lamp']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        total_lights = 0\n        for light_type in lighting_types:\n            count = get_object_count(one_hot[b:b+1], light_type, idx_to_labels)\n            total_lights += count\n        \n        if total_lights >= 1:\n            rewards[b] = 0.0\n        else:\n            rewards[b] = -3.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the adequate_lighting reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    pendant_idx = labels_to_idx.get('pendant_lamp', 13)\n    ceiling_idx = labels_to_idx.get('ceiling_lamp', 3)\n    chair_idx = labels_to_idx.get('dining_chair', 10)\n    \n    # Scene 1: Has pendant lamp\n    num_objects_1 = 2\n    class_label_indices_1 = [pendant_idx, chair_idx]\n    translations_1 = [(0, 2.5, 0), (1, 0.4, 0)]\n    sizes_1 = [(0.2, 0.3, 0.2), (0.3, 0.4, 0.3)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has ceiling lamp\n    num_objects_2 = 2\n    class_label_indices_2 = [ceiling_idx, chair_idx]\n    translations_2 = [(0, 2.7, 0), (1, 0.4, 0)]\n    sizes_2 = [(0.3, 0.1, 0.3), (0.3, 0.4, 0.3)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No lighting\n    num_objects_3 = 2\n    class_label_indices_3 = [chair_idx, chair_idx]\n    translations_3 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_3 = [(0.3, 0.4, 0.3), (0.3, 0.4, 0.3)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    assert rewards.shape[0] == 3\n    \n    assert rewards[0] >= -0.1, \"Scene 1 should have no penalty (has pendant lamp)\"\n    assert rewards[1] >= -0.1, \"Scene 2 should have no penalty (has ceiling lamp)\"\n    assert rewards[2] <= -2.9, \"Scene 3 should have penalty (no lighting)\"\n    print(\"All tests passed for adequate_lighting!\")",
            "success_threshold": -0.5
        },
        {
            "id": "R7",
            "constraint_id": "C7",
            "name": "minimal_living_room_furniture",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Penalize presence of living room furniture that doesn't belong in classroom.\n    \n    Returns:\n        reward: (B,) tensor - penalty for each living room furniture item\n    '''\n    utility_functions = get_all_utility_functions()\n    get_object_count = utility_functions[\"get_object_count_in_a_scene\"][\"function\"]\n    \n    one_hot = parsed_scenes['one_hot']\n    B = one_hot.shape[0]\n    device = parsed_scenes['device']\n    \n    living_room_types = ['multi_seat_sofa', 'loveseat_sofa', 'l_shaped_sofa', 'chaise_longue_sofa', \n                         'lazy_sofa', 'coffee_table', 'tv_stand', 'lounge_chair']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        total_living_room_items = 0\n        for lr_type in living_room_types:\n            count = get_object_count(one_hot[b:b+1], lr_type, idx_to_labels)\n            total_living_room_items += count\n        \n        rewards[b] = -total_living_room_items * 2.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the minimal_living_room_furniture reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    chair_idx = labels_to_idx.get('dining_chair', 10)\n    table_idx = labels_to_idx.get('dining_table', 11)\n    sofa_idx = labels_to_idx.get('multi_seat_sofa', 16)\n    coffee_idx = labels_to_idx.get('coffee_table', 6)\n    tv_idx = labels_to_idx.get('tv_stand', 21)\n    \n    # Scene 1: No living room furniture (good)\n    num_objects_1 = 3\n    class_label_indices_1 = [chair_idx, chair_idx, table_idx]\n    translations_1 = [(0, 0.4, 0), (1, 0.4, 0), (0.5, 0.4, 0.5)]\n    sizes_1 = [(0.3, 0.4, 0.3), (0.3, 0.4, 0.3), (0.8, 0.4, 0.5)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has 1 sofa (bad)\n    num_objects_2 = 3\n    class_label_indices_2 = [chair_idx, sofa_idx, table_idx]\n    translations_2 = [(0, 0.4, 0), (2, 0.5, 0), (0.5, 0.4, 0.5)]\n    sizes_2 = [(0.3, 0.4, 0.3), (1.0, 0.5, 0.8), (0.8, 0.4, 0.5)]\n    orientations_2 = [(1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Has multiple living room items (worse)\n    num_objects_3 = 4\n    class_label_indices_3 = [sofa_idx, coffee_idx, tv_idx, chair_idx]\n    translations_3 = [(0, 0.5, 0), (1, 0.3, 0), (2, 0.4, 0), (3, 0.4, 0)]\n    sizes_3 = [(1.0, 0.5, 0.8), (0.5, 0.3, 0.5), (0.8, 0.5, 0.4), (0.3, 0.4, 0.3)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    assert rewards.shape[0] == 3\n    \n    assert rewards[0] >= -0.1, \"Scene 1 should have no penalty (no living room furniture)\"\n    assert rewards[1] <= -1.9, \"Scene 2 should have penalty (1 sofa)\"\n    assert rewards[2] <= -5.9, \"Scene 3 should have higher penalty (3 living room items)\"\n    print(\"All tests passed for minimal_living_room_furniture!\")",
            "success_threshold": -0.5
        },
        {
            "id": "R8",
            "constraint_id": "C8",
            "name": "storage_or_display_availability",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Reward for having at least one storage/display unit for classroom materials.\n    \n    Returns:\n        reward: (B,) tensor - 0 if has storage, negative penalty otherwise\n    '''\n    utility_functions = get_all_utility_functions()\n    get_object_count = utility_functions[\"get_object_count_in_a_scene\"][\"function\"]\n    \n    one_hot = parsed_scenes['one_hot']\n    B = one_hot.shape[0]\n    device = parsed_scenes['device']\n    \n    storage_types = ['bookshelf', 'cabinet', 'shelf']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        has_storage = False\n        for storage_type in storage_types:\n            count = get_object_count(one_hot[b:b+1], storage_type, idx_to_labels)\n            if count > 0:\n                has_storage = True\n                break\n        \n        if has_storage:\n            rewards[b] = 0.0\n        else:\n            rewards[b] = -3.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Test the storage_or_display_availability reward function.\n    '''\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions[\"create_scene_for_testing\"][\"function\"]\n    \n    labels_to_idx = {v: int(k) for k, v in idx_to_labels.items()}\n    bookshelf_idx = labels_to_idx.get('bookshelf', 1)\n    cabinet_idx = labels_to_idx.get('cabinet', 2)\n    chair_idx = labels_to_idx.get('dining_chair', 10)\n    shelf_idx = labels_to_idx.get('shelf', 19)\n    \n    # Scene 1: Has bookshelf\n    num_objects_1 = 2\n    class_label_indices_1 = [bookshelf_idx, chair_idx]\n    translations_1 = [(0, 0.8, 0), (2, 0.4, 0)]\n    sizes_1 = [(0.4, 0.8, 0.3), (0.3, 0.4, 0.3)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has cabinet\n    num_objects_2 = 2\n    class_label_indices_2 = [cabinet_idx, chair_idx]\n    translations_2 = [(0, 0.6, 0), (2, 0.4, 0)]\n    sizes_2 = [(0.5, 0.6, 0.4), (0.3, 0.4, 0.3)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No storage\n    num_objects_3 = 2\n    class_label_indices_3 = [chair_idx, chair_idx]\n    translations_3 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_3 = [(0.3, 0.4, 0.3), (0.3, 0.4, 0.3)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    assert rewards.shape[0] == 3\n    \n    assert rewards[0] >= -0.1, \"Scene 1 should have no penalty (has bookshelf)\"\n    assert rewards[1] >= -0.1, \"Scene 2 should have no penalty (has cabinet)\"\n    assert rewards[2] <= -2.9, \"Scene 3 should have penalty (no storage)\"\n    print(\"All tests passed for storage_or_display_availability!\")",
            "success_threshold": -0.5
        }
    ],
    "inpaint": {
        "dining_chair": 10
    }
}