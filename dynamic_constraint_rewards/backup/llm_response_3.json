{
    "constraints": [
        {
            "id": "SC1",
            "name": "minimum_seating_capacity",
            "description": "Ensure the scene contains seating for at least 10 students. Count all seating furniture (dining_chair, stool, armchair, lounge_chair, chinese_chair) and verify total capacity â‰¥ 10."
        },
        {
            "id": "SC2",
            "name": "has_teaching_workspace",
            "description": "Verify the scene contains at least one desk or console_table that can serve as a teacher's workspace/teaching station."
        },
        {
            "id": "SC3",
            "name": "sufficient_student_workspace",
            "description": "Ensure there are adequate work surfaces for students. Count dining_table, desk, or console_table instances and verify at least 2 such surfaces exist for a 10-student classroom."
        },
        {
            "id": "SC4",
            "name": "chair_to_table_proximity",
            "description": "Verify that seating positions (chairs/stools) have reasonable proximity to table surfaces within 1.5m, ensuring students can access workspace."
        },
        {
            "id": "SC5",
            "name": "adequate_lighting",
            "description": "Check for presence of sufficient lighting fixtures (pendant_lamp, ceiling_lamp) appropriate for a learning environment. Minimum 1-2 light sources for a classroom."
        },
        {
            "id": "SC6",
            "name": "reduced_living_room_furniture",
            "description": "Penalize presence of typical living room furniture that doesn't belong in a classroom. Focus on most common living room items: sofas (multi_seat_sofa, loveseat_sofa, l_shaped_sofa), coffee_tables, and tv_stands."
        },
        {
            "id": "SC7",
            "name": "storage_availability",
            "description": "Verify presence of at least one storage/display furniture unit (bookshelf, cabinet, shelf) for classroom materials and student belongings."
        }
    ],
    "rewards": [
        {
            "id": "SR1",
            "constraint_id": "SC1",
            "name": "minimum_seating_capacity",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions, create_scene_for_testing\n\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Ensure the scene contains seating for at least 10 students.\n    Count all seating furniture: dining_chair, stool, armchair, lounge_chair, chinese_chair\n    Reward: 0 if count >= 10, otherwise penalty of -(10 - count)\n    '''\n    utility_functions = get_all_utility_functions()\n    one_hot = parsed_scenes['one_hot']  # shape (B, N, num_classes)\n    B = one_hot.shape[0]\n    \n    seating_types = ['dining_chair', 'stool', 'armchair', 'lounge_chair', 'chinese_chair']\n    rewards = []\n    \n    for i in range(B):\n        scene_one_hot = one_hot[i].unsqueeze(0)  # (1, N, num_classes)\n        total_seats = 0\n        \n        for seat_type in seating_types:\n            count = utility_functions['get_object_count_in_a_scene']['function'](\n                scene_one_hot, seat_type, idx_to_labels\n            )\n            total_seats += count\n        \n        if total_seats >= 10:\n            reward_val = 0.0\n        else:\n            reward_val = -(10 - total_seats)\n        \n        rewards.append(reward_val)\n    \n    reward = torch.tensor(rewards, device=parsed_scenes['device'], dtype=torch.float)\n    return reward\n\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    import torch\n    \n    # Scene 1: Exactly 10 chairs (satisfies constraint)\n    num_objects_1 = 10\n    class_label_indices_1 = [10] * 10  # dining_chair\n    translations_1 = [(i*0.8, 0.5, 0) for i in range(10)]\n    sizes_1 = [(0.3, 0.5, 0.3)] * 10\n    orientations_1 = [(1, 0)] * 10\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Only 7 chairs (does not satisfy)\n    num_objects_2 = 7\n    class_label_indices_2 = [10] * 7\n    translations_2 = [(i*0.8, 0.5, 0) for i in range(7)]\n    sizes_2 = [(0.3, 0.5, 0.3)] * 7\n    orientations_2 = [(1, 0)] * 7\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: 12 chairs (exceeds requirement)\n    num_objects_3 = 12\n    class_label_indices_3 = [10] * 12\n    translations_3 = [(i*0.8, 0.5, 0) for i in range(12)]\n    sizes_3 = [(0.3, 0.5, 0.3)] * 12\n    orientations_3 = [(1, 0)] * 12\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0) for k in tensor_keys\n    }\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Minimum Seating Capacity Rewards:\", rewards)\n    \n    # Test cases\n    assert torch.isclose(rewards[0], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[1], torch.tensor(-3.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[2], torch.tensor(0.0, device=parsed_scenes['device']))\n    \n    return rewards\n",
            "success_threshold": "0.0"
        },
        {
            "id": "SR2",
            "constraint_id": "SC2",
            "name": "has_teaching_workspace",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions, create_scene_for_testing\n\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Verify the scene contains at least one desk or console_table for teacher workspace.\n    Reward: 0 if at least 1 exists, otherwise -1\n    '''\n    utility_functions = get_all_utility_functions()\n    one_hot = parsed_scenes['one_hot']\n    B = one_hot.shape[0]\n    \n    workspace_types = ['desk', 'console_table']\n    rewards = []\n    \n    for i in range(B):\n        scene_one_hot = one_hot[i].unsqueeze(0)\n        total_workspace = 0\n        \n        for ws_type in workspace_types:\n            count = utility_functions['get_object_count_in_a_scene']['function'](\n                scene_one_hot, ws_type, idx_to_labels\n            )\n            total_workspace += count\n        \n        if total_workspace >= 1:\n            reward_val = 0.0\n        else:\n            reward_val = -1.0\n        \n        rewards.append(reward_val)\n    \n    reward = torch.tensor(rewards, device=parsed_scenes['device'], dtype=torch.float)\n    return reward\n\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    import torch\n    \n    # Scene 1: Has desk (satisfies)\n    num_objects_1 = 1\n    class_label_indices_1 = [9]  # desk\n    translations_1 = [(2, 0.4, 2)]\n    sizes_1 = [(0.6, 0.4, 0.4)]\n    orientations_1 = [(1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has console_table (satisfies)\n    num_objects_2 = 1\n    class_label_indices_2 = [7]  # console_table\n    translations_2 = [(2, 0.4, 2)]\n    sizes_2 = [(0.6, 0.4, 0.4)]\n    orientations_2 = [(1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No workspace furniture\n    num_objects_3 = 2\n    class_label_indices_3 = [10, 10]  # only chairs\n    translations_3 = [(0, 0.5, 0), (1, 0.5, 0)]\n    sizes_3 = [(0.3, 0.5, 0.3), (0.3, 0.5, 0.3)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0) for k in tensor_keys\n    }\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Teaching Workspace Rewards:\", rewards)\n    \n    assert torch.isclose(rewards[0], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[1], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[2], torch.tensor(-1.0, device=parsed_scenes['device']))\n    \n    return rewards\n",
            "success_threshold": "0.0"
        },
        {
            "id": "SR3",
            "constraint_id": "SC3",
            "name": "sufficient_student_workspace",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions, create_scene_for_testing\n\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Ensure there are at least 2 work surfaces (dining_table, desk, console_table) for students.\n    Reward: 0 if count >= 2, otherwise -(2 - count)\n    '''\n    utility_functions = get_all_utility_functions()\n    one_hot = parsed_scenes['one_hot']\n    B = one_hot.shape[0]\n    \n    workspace_types = ['dining_table', 'desk', 'console_table']\n    rewards = []\n    \n    for i in range(B):\n        scene_one_hot = one_hot[i].unsqueeze(0)\n        total_tables = 0\n        \n        for table_type in workspace_types:\n            count = utility_functions['get_object_count_in_a_scene']['function'](\n                scene_one_hot, table_type, idx_to_labels\n            )\n            total_tables += count\n        \n        if total_tables >= 2:\n            reward_val = 0.0\n        else:\n            reward_val = -(2 - total_tables)\n        \n        rewards.append(reward_val)\n    \n    reward = torch.tensor(rewards, device=parsed_scenes['device'], dtype=torch.float)\n    return reward\n\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    import torch\n    \n    # Scene 1: Has 2 dining tables (satisfies)\n    num_objects_1 = 2\n    class_label_indices_1 = [11, 11]  # dining_table\n    translations_1 = [(1, 0.4, 1), (3, 0.4, 1)]\n    sizes_1 = [(0.8, 0.4, 0.6), (0.8, 0.4, 0.6)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has only 1 table\n    num_objects_2 = 1\n    class_label_indices_2 = [11]\n    translations_2 = [(2, 0.4, 2)]\n    sizes_2 = [(0.8, 0.4, 0.6)]\n    orientations_2 = [(1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Has 3 tables (exceeds)\n    num_objects_3 = 3\n    class_label_indices_3 = [11, 11, 9]  # 2 dining_table + 1 desk\n    translations_3 = [(1, 0.4, 1), (3, 0.4, 1), (5, 0.4, 1)]\n    sizes_3 = [(0.8, 0.4, 0.6), (0.8, 0.4, 0.6), (0.6, 0.4, 0.4)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0) for k in tensor_keys\n    }\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Sufficient Student Workspace Rewards:\", rewards)\n    \n    assert torch.isclose(rewards[0], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[1], torch.tensor(-1.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[2], torch.tensor(0.0, device=parsed_scenes['device']))\n    \n    return rewards\n",
            "success_threshold": "0.0"
        },
        {
            "id": "SR4",
            "constraint_id": "SC4",
            "name": "chair_to_table_proximity",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions, create_scene_for_testing\n\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Verify that seating has reasonable proximity to tables (within 1.5m).\n    For each chair/stool, check if there's a table within 1.5m.\n    Reward: 0 if all chairs have nearby table, otherwise -1 per unpaired chair\n    '''\n    utility_functions = get_all_utility_functions()\n    positions = parsed_scenes['positions']  # (B, N, 3)\n    object_indices = parsed_scenes['object_indices']  # (B, N)\n    is_empty = parsed_scenes['is_empty']  # (B, N)\n    B = positions.shape[0]\n    N = positions.shape[1]\n    \n    seating_types = ['dining_chair', 'stool', 'armchair', 'lounge_chair', 'chinese_chair']\n    table_types = ['dining_table', 'desk', 'console_table']\n    max_distance = 1.5\n    \n    rewards = []\n    \n    for i in range(B):\n        # Find all chairs and tables in this scene\n        chair_positions = []\n        table_positions = []\n        \n        for j in range(N):\n            if is_empty[i, j]:\n                continue\n            \n            obj_idx = int(object_indices[i, j].item())\n            obj_label = idx_to_labels[obj_idx]\n            pos = positions[i, j]\n            \n            if obj_label in seating_types:\n                chair_positions.append(pos)\n            elif obj_label in table_types:\n                table_positions.append(pos)\n        \n        if len(chair_positions) == 0:\n            rewards.append(0.0)\n            continue\n        \n        if len(table_positions) == 0:\n            # No tables but have chairs - penalize all chairs\n            rewards.append(-len(chair_positions))\n            continue\n        \n        # Count chairs without nearby table\n        unpaired_chairs = 0\n        for chair_pos in chair_positions:\n            has_nearby_table = False\n            for table_pos in table_positions:\n                dist = utility_functions['distance_2d']['function'](chair_pos, table_pos)\n                if dist.item() <= max_distance:\n                    has_nearby_table = True\n                    break\n            \n            if not has_nearby_table:\n                unpaired_chairs += 1\n        \n        if unpaired_chairs == 0:\n            reward_val = 0.0\n        else:\n            reward_val = -unpaired_chairs\n        \n        rewards.append(reward_val)\n    \n    reward = torch.tensor(rewards, device=parsed_scenes['device'], dtype=torch.float)\n    return reward\n\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    import torch\n    \n    # Scene 1: 2 chairs near a table (within 1.5m)\n    num_objects_1 = 3\n    class_label_indices_1 = [10, 10, 11]  # 2 chairs + 1 table\n    translations_1 = [(1, 0.5, 1), (2, 0.5, 1), (1.5, 0.4, 1.8)]\n    sizes_1 = [(0.3, 0.5, 0.3), (0.3, 0.5, 0.3), (0.8, 0.4, 0.6)]\n    orientations_1 = [(1, 0), (1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: 2 chairs but one is far from table (>1.5m)\n    num_objects_2 = 3\n    class_label_indices_2 = [10, 10, 11]\n    translations_2 = [(1, 0.5, 1), (5, 0.5, 1), (1.5, 0.4, 1.8)]  # second chair far\n    sizes_2 = [(0.3, 0.5, 0.3), (0.3, 0.5, 0.3), (0.8, 0.4, 0.6)]\n    orientations_2 = [(1, 0), (1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Chairs but no table\n    num_objects_3 = 2\n    class_label_indices_3 = [10, 10]\n    translations_3 = [(1, 0.5, 1), (2, 0.5, 1)]\n    sizes_3 = [(0.3, 0.5, 0.3), (0.3, 0.5, 0.3)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0) for k in tensor_keys\n    }\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Chair to Table Proximity Rewards:\", rewards)\n    \n    assert torch.isclose(rewards[0], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[1], torch.tensor(-1.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[2], torch.tensor(-2.0, device=parsed_scenes['device']))\n    \n    return rewards\n",
            "success_threshold": "0.0"
        },
        {
            "id": "SR5",
            "constraint_id": "SC5",
            "name": "adequate_lighting",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions, create_scene_for_testing\n\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Check for adequate lighting: at least 1 lighting fixture (pendant_lamp or ceiling_lamp).\n    Reward: 0 if at least 1 light, otherwise -1\n    '''\n    utility_functions = get_all_utility_functions()\n    one_hot = parsed_scenes['one_hot']\n    B = one_hot.shape[0]\n    \n    lighting_types = ['pendant_lamp', 'ceiling_lamp']\n    rewards = []\n    \n    for i in range(B):\n        scene_one_hot = one_hot[i].unsqueeze(0)\n        total_lights = 0\n        \n        for light_type in lighting_types:\n            count = utility_functions['get_object_count_in_a_scene']['function'](\n                scene_one_hot, light_type, idx_to_labels\n            )\n            total_lights += count\n        \n        if total_lights >= 1:\n            reward_val = 0.0\n        else:\n            reward_val = -1.0\n        \n        rewards.append(reward_val)\n    \n    reward = torch.tensor(rewards, device=parsed_scenes['device'], dtype=torch.float)\n    return reward\n\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    import torch\n    \n    # Scene 1: Has ceiling lamp\n    num_objects_1 = 1\n    class_label_indices_1 = [3]  # ceiling_lamp\n    translations_1 = [(2, 2.8, 2)]\n    sizes_1 = [(0.3, 0.3, 0.3)]\n    orientations_1 = [(1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has pendant lamp\n    num_objects_2 = 1\n    class_label_indices_2 = [17]  # pendant_lamp\n    translations_2 = [(2, 2.5, 2)]\n    sizes_2 = [(0.2, 0.4, 0.2)]\n    orientations_2 = [(1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No lighting\n    num_objects_3 = 1\n    class_label_indices_3 = [10]  # just a chair\n    translations_3 = [(2, 0.5, 2)]\n    sizes_3 = [(0.3, 0.5, 0.3)]\n    orientations_3 = [(1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0) for k in tensor_keys\n    }\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Adequate Lighting Rewards:\", rewards)\n    \n    assert torch.isclose(rewards[0], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[1], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[2], torch.tensor(-1.0, device=parsed_scenes['device']))\n    \n    return rewards\n",
            "success_threshold": "0.0"
        },
        {
            "id": "SR6",
            "constraint_id": "SC6",
            "name": "reduced_living_room_furniture",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions, create_scene_for_testing\n\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Penalize presence of living room furniture: sofas, coffee_table, tv_stand.\n    Reward: 0 if none present, otherwise -1 per item (max penalty -5)\n    '''\n    utility_functions = get_all_utility_functions()\n    one_hot = parsed_scenes['one_hot']\n    B = one_hot.shape[0]\n    \n    unwanted_types = ['multi_seat_sofa', 'loveseat_sofa', 'l_shaped_sofa', 'coffee_table', 'tv_stand']\n    rewards = []\n    \n    for i in range(B):\n        scene_one_hot = one_hot[i].unsqueeze(0)\n        total_unwanted = 0\n        \n        for unwanted_type in unwanted_types:\n            count = utility_functions['get_object_count_in_a_scene']['function'](\n                scene_one_hot, unwanted_type, idx_to_labels\n            )\n            total_unwanted += count\n        \n        if total_unwanted == 0:\n            reward_val = 0.0\n        else:\n            reward_val = -min(total_unwanted, 5)\n        \n        rewards.append(reward_val)\n    \n    reward = torch.tensor(rewards, device=parsed_scenes['device'], dtype=torch.float)\n    return reward\n\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    import torch\n    \n    # Scene 1: No living room furniture\n    num_objects_1 = 2\n    class_label_indices_1 = [10, 11]  # chair + table\n    translations_1 = [(1, 0.5, 1), (2, 0.4, 1)]\n    sizes_1 = [(0.3, 0.5, 0.3), (0.8, 0.4, 0.6)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has 1 sofa and 1 coffee table\n    num_objects_2 = 2\n    class_label_indices_2 = [16, 6]  # multi_seat_sofa + coffee_table\n    translations_2 = [(2, 0.4, 2), (3, 0.3, 3)]\n    sizes_2 = [(1.0, 0.4, 0.6), (0.5, 0.3, 0.5)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Has 3 unwanted items\n    num_objects_3 = 3\n    class_label_indices_3 = [16, 6, 21]  # sofa + coffee_table + tv_stand\n    translations_3 = [(2, 0.4, 2), (3, 0.3, 3), (4, 0.5, 4)]\n    sizes_3 = [(1.0, 0.4, 0.6), (0.5, 0.3, 0.5), (0.8, 0.5, 0.4)]\n    orientations_3 = [(1, 0), (1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0) for k in tensor_keys\n    }\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Reduced Living Room Furniture Rewards:\", rewards)\n    \n    assert torch.isclose(rewards[0], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[1], torch.tensor(-2.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[2], torch.tensor(-3.0, device=parsed_scenes['device']))\n    \n    return rewards\n",
            "success_threshold": "0.0"
        },
        {
            "id": "SR7",
            "constraint_id": "SC7",
            "name": "storage_availability",
            "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions, create_scene_for_testing\n\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Verify presence of at least one storage unit (bookshelf, cabinet, shelf).\n    Reward: 0 if at least 1 exists, otherwise -1\n    '''\n    utility_functions = get_all_utility_functions()\n    one_hot = parsed_scenes['one_hot']\n    B = one_hot.shape[0]\n    \n    storage_types = ['bookshelf', 'cabinet', 'shelf']\n    rewards = []\n    \n    for i in range(B):\n        scene_one_hot = one_hot[i].unsqueeze(0)\n        total_storage = 0\n        \n        for storage_type in storage_types:\n            count = utility_functions['get_object_count_in_a_scene']['function'](\n                scene_one_hot, storage_type, idx_to_labels\n            )\n            total_storage += count\n        \n        if total_storage >= 1:\n            reward_val = 0.0\n        else:\n            reward_val = -1.0\n        \n        rewards.append(reward_val)\n    \n    reward = torch.tensor(rewards, device=parsed_scenes['device'], dtype=torch.float)\n    return reward\n\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    import torch\n    \n    # Scene 1: Has bookshelf\n    num_objects_1 = 1\n    class_label_indices_1 = [1]  # bookshelf\n    translations_1 = [(1, 1.0, 1)]\n    sizes_1 = [(0.4, 1.0, 0.3)]\n    orientations_1 = [(1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has cabinet\n    num_objects_2 = 1\n    class_label_indices_2 = [2]  # cabinet\n    translations_2 = [(2, 0.5, 2)]\n    sizes_2 = [(0.5, 0.5, 0.4)]\n    orientations_2 = [(1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No storage furniture\n    num_objects_3 = 2\n    class_label_indices_3 = [10, 11]  # chair + table\n    translations_3 = [(1, 0.5, 1), (2, 0.4, 2)]\n    sizes_3 = [(0.3, 0.5, 0.3), (0.8, 0.4, 0.6)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0) for k in tensor_keys\n    }\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Storage Availability Rewards:\", rewards)\n    \n    assert torch.isclose(rewards[0], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[1], torch.tensor(0.0, device=parsed_scenes['device']))\n    assert torch.isclose(rewards[2], torch.tensor(-1.0, device=parsed_scenes['device']))\n    \n    return rewards\n",
            "success_threshold": "0.0"
        }
    ],
    "inpaint": {
        "dining_chair": 10
    }
}