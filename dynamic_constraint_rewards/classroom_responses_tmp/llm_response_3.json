{
  "constraints": [
    {
      "id": "SC1",
      "name": "minimum_student_seating",
      "description": "Ensures at least 10 seating positions are available (dining chairs, armchairs, lounge chairs, stools, or sofas with appropriate capacity)"
    },
    {
      "id": "SC2",
      "name": "desk_or_table_presence",
      "description": "Verifies that at least one desk or dining table exists for classroom activities"
    },
    {
      "id": "SC3",
      "name": "adequate_lighting",
      "description": "Ensures at least one ceiling lamp or pendant lamp is present for classroom illumination"
    },
    {
      "id": "SC4",
      "name": "storage_furniture_present",
      "description": "Verifies presence of at least one storage unit (bookshelf, cabinet, or shelf) for classroom materials and supplies"
    },
    {
      "id": "SC5",
      "name": "chairs_near_tables_relaxed",
      "description": "Ensures that at least 50% of seating furniture is positioned within reasonable distance (2.5m instead of 1.5m) of desks or tables for functional use - relaxed version to make it more learnable"
    },
    {
      "id": "SC6",
      "name": "forward_facing_tendency",
      "description": "Encourages chairs to have similar orientations by rewarding lower circular variance - uses softer thresholds (0.8 radians ~46 degrees instead of 0.3) to make it more achievable for the baseline model"
    },
    {
      "id": "SC7",
      "name": "spacing_consistency_relaxed",
      "description": "Checks that seating positions maintain relatively consistent spacing with relaxed tolerance (1.0m variance instead of 0.5m) to create organized arrangements - easier version for learning"
    }
  ],
  "rewards": [
    {
      "id": "SR1",
      "constraint_id": "SC1",
      "name": "minimum_student_seating",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Ensures at least 10 seating positions are available.\n    Counts: dining_chair (1 seat), armchair (1), lounge_chair (1), stool (1),\n    chinese_chair (1), multi_seat_sofa (3), loveseat_sofa (2), l_shaped_sofa (4),\n    chaise_longue_sofa (2), lazy_sofa (1)\n    \n    Reward: 0 if >= 10 seats, negative penalty proportional to shortage otherwise\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    B = parsed_scenes['positions'].shape[0]\n    device = parsed_scenes['device']\n    \n    # Seating capacity map\n    seating_capacity = {\n        'dining_chair': 1,\n        'armchair': 1,\n        'lounge_chair': 1,\n        'stool': 1,\n        'chinese_chair': 1,\n        'multi_seat_sofa': 3,\n        'loveseat_sofa': 2,\n        'l_shaped_sofa': 4,\n        'chaise_longue_sofa': 2,\n        'lazy_sofa': 1\n    }\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        total_seats = 0\n        \n        for furniture_type, capacity in seating_capacity.items():\n            count = utility_functions['get_object_count_in_a_scene']['function'](\n                parsed_scenes['one_hot'][b:b+1],\n                furniture_type,\n                idx_to_labels\n            )\n            total_seats += count * capacity\n        \n        # Target is 10 seats\n        if total_seats >= 10:\n            rewards[b] = 0.0\n        else:\n            # Penalty proportional to shortage, capped at -10\n            shortage = 10 - total_seats\n            rewards[b] = -min(shortage * 1.0, 10.0)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    from dynamic_constraint_rewards.utilities import get_all_utility_functions\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions['create_scene_for_testing']['function']\n    \n    # Scene 1: Exactly 10 dining chairs (satisfies constraint)\n    num_objects_1 = 10\n    class_label_indices_1 = [10] * 10  # dining_chair\n    translations_1 = [(i*1.5, 0.4, 0) for i in range(10)]\n    sizes_1 = [(0.25, 0.4, 0.25)] * 10\n    orientations_1 = [(1, 0)] * 10\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: 2 multi_seat_sofas (2*3=6 seats) + 4 dining chairs = 10 seats\n    num_objects_2 = 6\n    class_label_indices_2 = [16, 16, 10, 10, 10, 10]  # multi_seat_sofa x2, dining_chair x4\n    translations_2 = [(0, 0.5, 0), (2, 0.5, 0), (4, 0.4, 0), (5, 0.4, 0), (6, 0.4, 0), (7, 0.4, 0)]\n    sizes_2 = [(1.0, 0.5, 0.5), (1.0, 0.5, 0.5), (0.25, 0.4, 0.25), (0.25, 0.4, 0.25), (0.25, 0.4, 0.25), (0.25, 0.4, 0.25)]\n    orientations_2 = [(1, 0)] * 6\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Only 5 dining chairs (insufficient)\n    num_objects_3 = 5\n    class_label_indices_3 = [10] * 5\n    translations_3 = [(i*1.5, 0.4, 0) for i in range(5)]\n    sizes_3 = [(0.25, 0.4, 0.25)] * 5\n    orientations_3 = [(1, 0)] * 5\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [0.0 (10 seats), 0.0 (10 seats), -5.0 (5 seats shortage)]\")\n    \n    assert rewards.shape[0] == 3, f\"Expected 3 rewards, got {rewards.shape[0]}\"\n    assert rewards[0] >= -0.1, f\"Scene 1 should satisfy (10 chairs): got {rewards[0]}\"\n    assert rewards[1] >= -0.1, f\"Scene 2 should satisfy (10 seats): got {rewards[1]}\"\n    assert rewards[2] < -4.0 and rewards[2] > -6.0, f\"Scene 3 should have ~-5 penalty (5 seats): got {rewards[2]}\"\n    print(\"All tests passed!\")",
      "success_threshold": -0.5
    },
    {
      "id": "SR2",
      "constraint_id": "SC2",
      "name": "desk_or_table_presence",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Verifies that at least one desk or dining table exists.\n    Reward: 0 if present, -5 if absent\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    B = parsed_scenes['positions'].shape[0]\n    device = parsed_scenes['device']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        desk_count = utility_functions['get_object_count_in_a_scene']['function'](\n            parsed_scenes['one_hot'][b:b+1],\n            'desk',\n            idx_to_labels\n        )\n        \n        dining_table_count = utility_functions['get_object_count_in_a_scene']['function'](\n            parsed_scenes['one_hot'][b:b+1],\n            'dining_table',\n            idx_to_labels\n        )\n        \n        total_count = desk_count + dining_table_count\n        \n        if total_count >= 1:\n            rewards[b] = 0.0\n        else:\n            rewards[b] = -5.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    from dynamic_constraint_rewards.utilities import get_all_utility_functions\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions['create_scene_for_testing']['function']\n    \n    # Scene 1: Has dining table\n    num_objects_1 = 2\n    class_label_indices_1 = [11, 10]  # dining_table, dining_chair\n    translations_1 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_1 = [(0.8, 0.4, 0.6), (0.25, 0.4, 0.25)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has desk\n    num_objects_2 = 2\n    class_label_indices_2 = [9, 10]  # desk, dining_chair\n    translations_2 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_2 = [(0.6, 0.4, 0.4), (0.25, 0.4, 0.25)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No desk or table\n    num_objects_3 = 2\n    class_label_indices_3 = [10, 10]  # only chairs\n    translations_3 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_3 = [(0.25, 0.4, 0.25), (0.25, 0.4, 0.25)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [0.0 (has table), 0.0 (has desk), -5.0 (no table/desk)]\")\n    \n    assert rewards.shape[0] == 3\n    assert rewards[0] >= -0.1, f\"Scene 1 should satisfy (has table): got {rewards[0]}\"\n    assert rewards[1] >= -0.1, f\"Scene 2 should satisfy (has desk): got {rewards[1]}\"\n    assert torch.isclose(rewards[2], torch.tensor(-5.0, device=rewards.device), atol=0.1), f\"Scene 3 should be -5.0: got {rewards[2]}\"\n    print(\"All tests passed!\")",
      "success_threshold": -0.5
    },
    {
      "id": "SR3",
      "constraint_id": "SC3",
      "name": "adequate_lighting",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Ensures at least one ceiling lamp or pendant lamp is present.\n    Reward: 0 if present, -5 if absent\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    B = parsed_scenes['positions'].shape[0]\n    device = parsed_scenes['device']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        ceiling_lamp_count = utility_functions['get_object_count_in_a_scene']['function'](\n            parsed_scenes['one_hot'][b:b+1],\n            'ceiling_lamp',\n            idx_to_labels\n        )\n        \n        pendant_lamp_count = utility_functions['get_object_count_in_a_scene']['function'](\n            parsed_scenes['one_hot'][b:b+1],\n            'pendant_lamp',\n            idx_to_labels\n        )\n        \n        total_count = ceiling_lamp_count + pendant_lamp_count\n        \n        if total_count >= 1:\n            rewards[b] = 0.0\n        else:\n            rewards[b] = -5.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    from dynamic_constraint_rewards.utilities import get_all_utility_functions\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions['create_scene_for_testing']['function']\n    \n    # Scene 1: Has ceiling lamp\n    num_objects_1 = 2\n    class_label_indices_1 = [3, 10]  # ceiling_lamp, dining_chair\n    translations_1 = [(2, 2.8, 2), (0, 0.4, 0)]\n    sizes_1 = [(0.3, 0.1, 0.3), (0.25, 0.4, 0.25)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has pendant lamp\n    num_objects_2 = 2\n    class_label_indices_2 = [17, 10]  # pendant_lamp, dining_chair\n    translations_2 = [(2, 2.5, 2), (0, 0.4, 0)]\n    sizes_2 = [(0.2, 0.3, 0.2), (0.25, 0.4, 0.25)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No lighting\n    num_objects_3 = 2\n    class_label_indices_3 = [10, 10]  # only chairs\n    translations_3 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_3 = [(0.25, 0.4, 0.25), (0.25, 0.4, 0.25)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [0.0 (has ceiling lamp), 0.0 (has pendant lamp), -5.0 (no lighting)]\")\n    \n    assert rewards.shape[0] == 3\n    assert rewards[0] >= -0.1, f\"Scene 1 should satisfy (has ceiling lamp): got {rewards[0]}\"\n    assert rewards[1] >= -0.1, f\"Scene 2 should satisfy (has pendant lamp): got {rewards[1]}\"\n    assert torch.isclose(rewards[2], torch.tensor(-5.0, device=rewards.device), atol=0.1), f\"Scene 3 should be -5.0: got {rewards[2]}\"\n    print(\"All tests passed!\")",
      "success_threshold": -0.5
    },
    {
      "id": "SR4",
      "constraint_id": "SC4",
      "name": "storage_furniture_present",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Verifies presence of at least one storage unit (bookshelf, cabinet, or shelf).\n    Reward: 0 if present, -5 if absent\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    B = parsed_scenes['positions'].shape[0]\n    device = parsed_scenes['device']\n    \n    rewards = torch.zeros(B, device=device)\n    \n    for b in range(B):\n        bookshelf_count = utility_functions['get_object_count_in_a_scene']['function'](\n            parsed_scenes['one_hot'][b:b+1],\n            'bookshelf',\n            idx_to_labels\n        )\n        \n        cabinet_count = utility_functions['get_object_count_in_a_scene']['function'](\n            parsed_scenes['one_hot'][b:b+1],\n            'cabinet',\n            idx_to_labels\n        )\n        \n        shelf_count = utility_functions['get_object_count_in_a_scene']['function'](\n            parsed_scenes['one_hot'][b:b+1],\n            'shelf',\n            idx_to_labels\n        )\n        \n        total_count = bookshelf_count + cabinet_count + shelf_count\n        \n        if total_count >= 1:\n            rewards[b] = 0.0\n        else:\n            rewards[b] = -5.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    from dynamic_constraint_rewards.utilities import get_all_utility_functions\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions['create_scene_for_testing']['function']\n    \n    # Scene 1: Has bookshelf\n    num_objects_1 = 2\n    class_label_indices_1 = [1, 10]  # bookshelf, dining_chair\n    translations_1 = [(0, 0.9, 0), (2, 0.4, 0)]\n    sizes_1 = [(0.4, 0.9, 0.3), (0.25, 0.4, 0.25)]\n    orientations_1 = [(1, 0), (1, 0)]\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Has cabinet\n    num_objects_2 = 2\n    class_label_indices_2 = [2, 10]  # cabinet, dining_chair\n    translations_2 = [(0, 0.5, 0), (2, 0.4, 0)]\n    sizes_2 = [(0.5, 0.5, 0.4), (0.25, 0.4, 0.25)]\n    orientations_2 = [(1, 0), (1, 0)]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: No storage furniture\n    num_objects_3 = 2\n    class_label_indices_3 = [10, 10]  # only chairs\n    translations_3 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_3 = [(0.25, 0.4, 0.25), (0.25, 0.4, 0.25)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [0.0 (has bookshelf), 0.0 (has cabinet), -5.0 (no storage)]\")\n    \n    assert rewards.shape[0] == 3\n    assert rewards[0] >= -0.1, f\"Scene 1 should satisfy (has bookshelf): got {rewards[0]}\"\n    assert rewards[1] >= -0.1, f\"Scene 2 should satisfy (has cabinet): got {rewards[1]}\"\n    assert torch.isclose(rewards[2], torch.tensor(-5.0, device=rewards.device), atol=0.1), f\"Scene 3 should be -5.0: got {rewards[2]}\"\n    print(\"All tests passed!\")",
      "success_threshold": -0.5
    },
    {
      "id": "SR5",
      "constraint_id": "SC5",
      "name": "chairs_near_tables_relaxed",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Ensures at least 50% of seating furniture is within 2.5m of desks or tables.\n    Relaxed version: distance threshold increased to 2.5m, only requires 50% compliance\n    Reward: 0 if >= 50% seats are near tables, penalty for lower percentage\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    B = parsed_scenes['positions'].shape[0]\n    N = parsed_scenes['positions'].shape[1]\n    device = parsed_scenes['device']\n    \n    seating_types = {'dining_chair', 'armchair', 'lounge_chair', 'stool', 'chinese_chair',\n                     'multi_seat_sofa', 'loveseat_sofa', 'l_shaped_sofa', 'chaise_longue_sofa', 'lazy_sofa'}\n    table_types = {'desk', 'dining_table'}\n    \n    rewards = torch.zeros(B, device=device)\n    distance_threshold = 2.5  # meters - relaxed from 1.5m\n    \n    for b in range(B):\n        # Find all seating and table positions\n        seat_positions = []\n        table_positions = []\n        \n        for n in range(N):\n            if parsed_scenes['is_empty'][b, n]:\n                continue\n            \n            obj_idx = parsed_scenes['object_indices'][b, n].item()\n            obj_label = idx_to_labels.get(obj_idx, 'unknown')\n            \n            if obj_label in seating_types:\n                seat_positions.append(parsed_scenes['positions'][b, n])\n            elif obj_label in table_types:\n                table_positions.append(parsed_scenes['positions'][b, n])\n        \n        if len(seat_positions) == 0:\n            # No seats to check\n            rewards[b] = 0.0\n            continue\n        \n        if len(table_positions) == 0:\n            # No tables but seats exist - moderate penalty\n            rewards[b] = -3.0\n            continue\n        \n        # Count seats within distance threshold\n        seats_near_table = 0\n        for seat_pos in seat_positions:\n            min_dist = float('inf')\n            for table_pos in table_positions:\n                # XZ plane distance\n                dist = torch.sqrt((seat_pos[0] - table_pos[0])**2 + (seat_pos[2] - table_pos[2])**2)\n                min_dist = min(min_dist, dist.item())\n            \n            if min_dist <= distance_threshold:\n                seats_near_table += 1\n        \n        # Calculate percentage of seats near tables\n        percentage_near = seats_near_table / len(seat_positions)\n        \n        if percentage_near >= 0.5:  # 50% threshold\n            rewards[b] = 0.0\n        else:\n            # Penalty proportional to shortfall, capped at -5\n            shortfall = 0.5 - percentage_near\n            rewards[b] = -min(shortfall * 10.0, 5.0)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    from dynamic_constraint_rewards.utilities import get_all_utility_functions\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions['create_scene_for_testing']['function']\n    \n    # Scene 1: All chairs near table (within 2.5m) - 100% compliance\n    num_objects_1 = 5\n    class_label_indices_1 = [11, 10, 10, 10, 10]  # dining_table + 4 chairs\n    translations_1 = [(2, 0.4, 2), (1.0, 0.4, 2), (3.0, 0.4, 2), (2, 0.4, 0.3), (2, 0.4, 3.7)]\n    sizes_1 = [(0.8, 0.4, 0.6), (0.25, 0.4, 0.25), (0.25, 0.4, 0.25), (0.25, 0.4, 0.25), (0.25, 0.4, 0.25)]\n    orientations_1 = [(1, 0)] * 5\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: 50% chairs near table - exactly at threshold\n    num_objects_2 = 5\n    class_label_indices_2 = [11, 10, 10, 10, 10]  # dining_table + 4 chairs (2 near, 2 far)\n    translations_2 = [(0, 0.4, 0), (1, 0.4, 0), (2, 0.4, 0), (5, 0.4, 5), (6, 0.4, 6)]\n    sizes_2 = [(0.8, 0.4, 0.6), (0.25, 0.4, 0.25), (0.25, 0.4, 0.25), (0.25, 0.4, 0.25), (0.25, 0.4, 0.25)]\n    orientations_2 = [(1, 0)] * 5\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Chairs without any table\n    num_objects_3 = 2\n    class_label_indices_3 = [10, 10]\n    translations_3 = [(0, 0.4, 0), (1, 0.4, 0)]\n    sizes_3 = [(0.25, 0.4, 0.25), (0.25, 0.4, 0.25)]\n    orientations_3 = [(1, 0), (1, 0)]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [~0.0 (all chairs near), ~0.0 (50% near), -3.0 (no table)]\")\n    \n    assert rewards.shape[0] == 3\n    assert rewards[0] >= -0.5, f\"Scene 1 should satisfy (all chairs near): got {rewards[0]}\"\n    assert rewards[1] >= -0.5, f\"Scene 2 should satisfy (50% near): got {rewards[1]}\"\n    assert rewards[2] <= -2.5 and rewards[2] >= -3.5, f\"Scene 3 should be ~-3.0 (no table): got {rewards[2]}\"\n    print(\"All tests passed!\")",
      "success_threshold": -0.5
    },
    {
      "id": "SR6",
      "constraint_id": "SC6",
      "name": "forward_facing_tendency",
      "code": "import torch\nimport math\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Encourages chairs to have similar orientations with relaxed threshold.\n    Uses circular standard deviation - lower is better.\n    Reward: 0 if std < 0.8 radians (~46 degrees), penalty proportional to std otherwise\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    B = parsed_scenes['positions'].shape[0]\n    N = parsed_scenes['positions'].shape[1]\n    device = parsed_scenes['device']\n    \n    seating_types = {'dining_chair', 'armchair', 'lounge_chair', 'stool', 'chinese_chair',\n                     'multi_seat_sofa', 'loveseat_sofa', 'l_shaped_sofa', 'chaise_longue_sofa', 'lazy_sofa'}\n    \n    rewards = torch.zeros(B, device=device)\n    angle_threshold = 0.8  # radians (~46 degrees) - relaxed from 0.3\n    \n    for b in range(B):\n        seat_angles = []\n        \n        for n in range(N):\n            if parsed_scenes['is_empty'][b, n]:\n                continue\n            \n            obj_idx = parsed_scenes['object_indices'][b, n].item()\n            obj_label = idx_to_labels.get(obj_idx, 'unknown')\n            \n            if obj_label in seating_types:\n                # Extract angle from orientation (cos, sin)\n                cos_theta = parsed_scenes['orientations'][b, n, 0].item()\n                sin_theta = parsed_scenes['orientations'][b, n, 1].item()\n                angle = math.atan2(sin_theta, cos_theta)\n                seat_angles.append(angle)\n        \n        if len(seat_angles) < 2:\n            # Need at least 2 seats to check alignment\n            rewards[b] = 0.0\n            continue\n        \n        # Calculate circular standard deviation\n        angles_tensor = torch.tensor(seat_angles, device=device)\n        \n        # Convert to unit vectors and compute mean direction\n        mean_cos = torch.cos(angles_tensor).mean()\n        mean_sin = torch.sin(angles_tensor).mean()\n        R = torch.sqrt(mean_cos**2 + mean_sin**2)\n        \n        # Circular standard deviation\n        circ_std = torch.sqrt(-2 * torch.log(R + 1e-8))\n        \n        if circ_std < angle_threshold:\n            rewards[b] = 0.0\n        else:\n            # Penalty increases with deviation, capped at -5\n            rewards[b] = -min((circ_std - angle_threshold).item() * 3.0, 5.0)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    from dynamic_constraint_rewards.utilities import get_all_utility_functions\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions['create_scene_for_testing']['function']\n    \n    # Scene 1: All chairs facing same direction (0 degrees)\n    num_objects_1 = 5\n    class_label_indices_1 = [10] * 5\n    translations_1 = [(i*1.5, 0.4, 0) for i in range(5)]\n    sizes_1 = [(0.25, 0.4, 0.25)] * 5\n    orientations_1 = [(1, 0)] * 5  # All facing 0 degrees\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Chairs with moderate variations (within threshold ~40 degrees)\n    import math\n    num_objects_2 = 4\n    class_label_indices_2 = [10] * 4\n    translations_2 = [(i*1.5, 0.4, 0) for i in range(4)]\n    sizes_2 = [(0.25, 0.4, 0.25)] * 4\n    # Variations: 0, 20, -20, 30 degrees\n    orientations_2 = [\n        (math.cos(0), math.sin(0)),\n        (math.cos(math.radians(20)), math.sin(math.radians(20))),\n        (math.cos(math.radians(-20)), math.sin(math.radians(-20))),\n        (math.cos(math.radians(30)), math.sin(math.radians(30)))\n    ]\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Chairs facing random directions\n    num_objects_3 = 4\n    class_label_indices_3 = [10] * 4\n    translations_3 = [(i*1.5, 0.4, 0) for i in range(4)]\n    sizes_3 = [(0.25, 0.4, 0.25)] * 4\n    orientations_3 = [\n        (1, 0),  # 0 degrees\n        (0, 1),  # 90 degrees\n        (-1, 0),  # 180 degrees\n        (0, -1)  # 270 degrees\n    ]\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [~0.0 (aligned), ~0.0 (moderate variance), <-2.0 (random)]\")\n    \n    assert rewards.shape[0] == 3\n    assert rewards[0] >= -0.5, f\"Scene 1 should be aligned: got {rewards[0]}\"\n    assert rewards[1] >= -1.0, f\"Scene 2 should be mostly aligned: got {rewards[1]}\"\n    assert rewards[2] < -1.5, f\"Scene 3 should be penalized (random directions): got {rewards[2]}\"\n    print(\"All tests passed!\")",
      "success_threshold": -0.5
    },
    {
      "id": "SR7",
      "constraint_id": "SC7",
      "name": "spacing_consistency_relaxed",
      "code": "import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    '''\n    Checks that seating positions maintain consistent spacing with relaxed tolerance.\n    Computes pairwise distances between adjacent seats and checks standard deviation.\n    Reward: 0 if spacing variance <= 1.0m, penalty proportional to variance otherwise\n    '''\n    utility_functions = get_all_utility_functions()\n    \n    B = parsed_scenes['positions'].shape[0]\n    N = parsed_scenes['positions'].shape[1]\n    device = parsed_scenes['device']\n    \n    seating_types = {'dining_chair', 'armchair', 'lounge_chair', 'stool', 'chinese_chair',\n                     'multi_seat_sofa', 'loveseat_sofa', 'l_shaped_sofa', 'chaise_longue_sofa', 'lazy_sofa'}\n    \n    rewards = torch.zeros(B, device=device)\n    spacing_threshold = 1.0  # meters variance allowed - relaxed from 0.5m\n    \n    for b in range(B):\n        seat_positions = []\n        \n        for n in range(N):\n            if parsed_scenes['is_empty'][b, n]:\n                continue\n            \n            obj_idx = parsed_scenes['object_indices'][b, n].item()\n            obj_label = idx_to_labels.get(obj_idx, 'unknown')\n            \n            if obj_label in seating_types:\n                pos = parsed_scenes['positions'][b, n]\n                seat_positions.append(pos)\n        \n        if len(seat_positions) < 3:\n            # Need at least 3 seats to check spacing consistency\n            rewards[b] = 0.0\n            continue\n        \n        # Sort seats by position (use x-coordinate primarily, then z)\n        seat_positions_sorted = sorted(seat_positions, key=lambda p: (p[0].item(), p[2].item()))\n        \n        # Calculate distances between adjacent seats\n        distances = []\n        for i in range(len(seat_positions_sorted) - 1):\n            pos1 = seat_positions_sorted[i]\n            pos2 = seat_positions_sorted[i + 1]\n            # XZ plane distance\n            dist = torch.sqrt((pos2[0] - pos1[0])**2 + (pos2[2] - pos1[2])**2)\n            distances.append(dist.item())\n        \n        if len(distances) == 0:\n            rewards[b] = 0.0\n            continue\n        \n        # Calculate standard deviation of distances\n        distances_tensor = torch.tensor(distances, device=device)\n        std_dev = torch.std(distances_tensor)\n        \n        if std_dev <= spacing_threshold:\n            rewards[b] = 0.0\n        else:\n            # Penalty increases with spacing variance, capped at -5\n            rewards[b] = -min((std_dev - spacing_threshold).item() * 3.0, 5.0)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    from dynamic_constraint_rewards.utilities import get_all_utility_functions\n    utility_functions = get_all_utility_functions()\n    create_scene_for_testing = utility_functions['create_scene_for_testing']['function']\n    \n    # Scene 1: Uniformly spaced chairs (1.5m apart)\n    num_objects_1 = 5\n    class_label_indices_1 = [10] * 5\n    translations_1 = [(i*1.5, 0.4, 0) for i in range(5)]  # Uniform 1.5m spacing\n    sizes_1 = [(0.25, 0.4, 0.25)] * 5\n    orientations_1 = [(1, 0)] * 5\n    scene_1 = create_scene_for_testing(room_type, num_objects_1, class_label_indices_1, translations_1, sizes_1, orientations_1)\n    \n    # Scene 2: Moderate variance in spacing (within threshold ~0.8m std)\n    num_objects_2 = 5\n    class_label_indices_2 = [10] * 5\n    translations_2 = [(0, 0.4, 0), (1.2, 0.4, 0), (2.6, 0.4, 0), (4.0, 0.4, 0), (5.5, 0.4, 0)]  # Moderate variance\n    sizes_2 = [(0.25, 0.4, 0.25)] * 5\n    orientations_2 = [(1, 0)] * 5\n    scene_2 = create_scene_for_testing(room_type, num_objects_2, class_label_indices_2, translations_2, sizes_2, orientations_2)\n    \n    # Scene 3: Highly irregular spacing (large variance)\n    num_objects_3 = 5\n    class_label_indices_3 = [10] * 5\n    translations_3 = [(0, 0.4, 0), (0.5, 0.4, 0), (2.5, 0.4, 0), (3.0, 0.4, 0), (7.0, 0.4, 0)]  # Very irregular\n    sizes_3 = [(0.25, 0.4, 0.25)] * 5\n    orientations_3 = [(1, 0)] * 5\n    scene_3 = create_scene_for_testing(room_type, num_objects_3, class_label_indices_3, translations_3, sizes_3, orientations_3)\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes['room_type'] = room_type\n    parsed_scenes['device'] = scene_1['device']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print(\"Rewards:\", rewards)\n    print(\"Expected: [~0.0 (uniform), ~0.0 (moderate variance), <-2.0 (irregular)]\")\n    \n    assert rewards.shape[0] == 3\n    assert rewards[0] >= -0.2, f\"Scene 1 should have uniform spacing: got {rewards[0]}\"\n    assert rewards[1] >= -1.0, f\"Scene 2 should have acceptable variance: got {rewards[1]}\"\n    assert rewards[2] < -1.5, f\"Scene 3 should be penalized (irregular spacing): got {rewards[2]}\"\n    print(\"All tests passed!\")",
      "success_threshold": -0.5
    }
  ],
  "inpaint": {
    "dining_chair": 10,
    "dining_table": 1,
    "ceiling_lamp": 1,
    "bookshelf": 1
  }
}
