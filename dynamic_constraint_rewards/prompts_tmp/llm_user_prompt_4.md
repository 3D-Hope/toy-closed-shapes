
        Original User Prompt: A bedroom with ceiling lamp above each corner of the bed.
        Final Constraints: [{'id': 'SC1', 'name': 'bed_presence', 'description': 'Verifies that at least one bed (double_bed, single_bed, or kids_bed) exists in the scene. This is a fundamental requirement for a bedroom.'}, {'id': 'SC2', 'name': 'ceiling_lamp_count', 'description': 'Ensures exactly 4 ceiling lamps are present in the scene, one for each corner of the bed.'}, {'id': 'SC3', 'name': 'ceiling_lamp_height', 'description': 'Ensures ceiling lamps are positioned at appropriate ceiling height (y ≈ 2.8m), not at floor level or other inappropriate heights.'}, {'id': 'SC4', 'name': 'lamps_near_bed_corners', 'description': 'Checks that ceiling lamps are positioned near the four corners of the bed in the XZ plane. This is a relaxed version that rewards proximity to corners rather than exact alignment.'}]
        Final Dynamic Reward Functions: [{'id': 'SR1', 'constraint_id': 'SC1', 'name': 'bed_presence', 'code': 'import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Reward for having at least one bed (double_bed, single_bed, or kids_bed) in the scene.\n    Returns 0 if at least one bed exists, -1 otherwise.\n    \'\'\'\n    utility_functions = get_all_utility_functions()\n    get_object_count = utility_functions["get_object_count_in_a_scene"]["function"]\n    \n    B = parsed_scenes[\'positions\'].shape[0]\n    rewards = torch.zeros(B, device=parsed_scenes[\'device\'])\n    \n    bed_types = ["double_bed", "single_bed", "kids_bed"]\n    \n    for i in range(B):\n        scene_one_hot = parsed_scenes[\'one_hot\'][i:i+1]\n        total_beds = 0\n        for bed_type in bed_types:\n            total_beds += get_object_count(scene_one_hot, bed_type, idx_to_labels)\n        \n        if total_beds < 1:\n            rewards[i] = -1.0\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions["create_scene_for_testing"]["function"]\n    \n    # Scene 1: Has double_bed (satisfies)\n    scene_1 = create_scene(\n        room_type=room_type,\n        num_objects=2,\n        class_label_indices=[8, 12],  # double_bed, nightstand\n        translations=[(1, 0.5, 1), (2, 0.3, 2)],\n        sizes=[(1.0, 0.4, 1.5), (0.4, 0.3, 0.4)],\n        orientations=[(1, 0), (1, 0)]\n    )\n    \n    # Scene 2: Has single_bed (satisfies)\n    scene_2 = create_scene(\n        room_type=room_type,\n        num_objects=2,\n        class_label_indices=[15, 12],  # single_bed, nightstand\n        translations=[(1, 0.4, 1), (2, 0.3, 2)],\n        sizes=[(0.6, 0.3, 1.2), (0.4, 0.3, 0.4)],\n        orientations=[(1, 0), (1, 0)]\n    )\n    \n    # Scene 3: No bed (fails)\n    scene_3 = create_scene(\n        room_type=room_type,\n        num_objects=2,\n        class_label_indices=[12, 20],  # nightstand, wardrobe\n        translations=[(2, 0.3, 2), (3, 1.0, 3)],\n        sizes=[(0.4, 0.3, 0.4), (0.8, 1.0, 0.5)],\n        orientations=[(1, 0), (1, 0)]\n    )\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes[\'room_type\'] = room_type\n    parsed_scenes[\'device\'] = scene_1[\'device\']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print("Rewards:", rewards)\n    print("Expected: [0.0, 0.0, -1.0]")\n    assert rewards.shape[0] == 3\n    assert rewards[0] == 0.0, f"Scene 1 should have reward 0.0, got {rewards[0]}"\n    assert rewards[1] == 0.0, f"Scene 2 should have reward 0.0, got {rewards[1]}"\n    assert rewards[2] == -1.0, f"Scene 3 should have reward -1.0, got {rewards[2]}"', 'success_threshold': 0.0}, {'id': 'SR2', 'constraint_id': 'SC2', 'name': 'ceiling_lamp_count', 'code': 'import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Reward for having exactly 4 ceiling lamps.\n    Returns 0 if exactly 4 ceiling lamps exist, negative penalty otherwise.\n    Penalty = -|count - 4| (linear penalty based on deviation from 4).\n    \'\'\'\n    utility_functions = get_all_utility_functions()\n    get_object_count = utility_functions["get_object_count_in_a_scene"]["function"]\n    \n    B = parsed_scenes[\'positions\'].shape[0]\n    rewards = torch.zeros(B, device=parsed_scenes[\'device\'])\n    \n    for i in range(B):\n        scene_one_hot = parsed_scenes[\'one_hot\'][i:i+1]\n        count = get_object_count(scene_one_hot, "ceiling_lamp", idx_to_labels)\n        \n        deviation = abs(count - 4)\n        rewards[i] = -float(deviation)\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions["create_scene_for_testing"]["function"]\n    \n    # Scene 1: Exactly 4 ceiling lamps (satisfies)\n    scene_1 = create_scene(\n        room_type=room_type,\n        num_objects=5,\n        class_label_indices=[3, 3, 3, 3, 8],  # 4 ceiling_lamps, double_bed\n        translations=[(0, 2.8, 0), (1, 2.8, 0), (2, 2.8, 1), (3, 2.8, 1), (2, 0.5, 2)],\n        sizes=[(0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (1.0, 0.4, 1.5)],\n        orientations=[(1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]\n    )\n    \n    # Scene 2: 2 ceiling lamps (fails - too few)\n    scene_2 = create_scene(\n        room_type=room_type,\n        num_objects=3,\n        class_label_indices=[3, 3, 8],  # 2 ceiling_lamps, double_bed\n        translations=[(0, 2.8, 0), (1, 2.8, 0), (2, 0.5, 2)],\n        sizes=[(0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (1.0, 0.4, 1.5)],\n        orientations=[(1, 0), (1, 0), (1, 0)]\n    )\n    \n    # Scene 3: 6 ceiling lamps (fails - too many)\n    scene_3 = create_scene(\n        room_type=room_type,\n        num_objects=7,\n        class_label_indices=[3, 3, 3, 3, 3, 3, 8],  # 6 ceiling_lamps, double_bed\n        translations=[(0, 2.8, 0), (1, 2.8, 0), (2, 2.8, 1), (3, 2.8, 1), (4, 2.8, 2), (5, 2.8, 2), (2, 0.5, 2)],\n        sizes=[(0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (1.0, 0.4, 1.5)],\n        orientations=[(1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]\n    )\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes[\'room_type\'] = room_type\n    parsed_scenes[\'device\'] = scene_1[\'device\']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print("Rewards:", rewards)\n    print("Expected: [0.0, -2.0, -2.0]")\n    assert rewards.shape[0] == 3\n    assert rewards[0] == 0.0, f"Scene 1 should have reward 0.0, got {rewards[0]}"\n    assert rewards[1] == -2.0, f"Scene 2 should have reward -2.0, got {rewards[1]}"\n    assert rewards[2] == -2.0, f"Scene 3 should have reward -2.0, got {rewards[2]}"', 'success_threshold': 0.0}, {'id': 'SR3', 'constraint_id': 'SC3', 'name': 'lamps_near_bed_corners', 'code': 'import torch\nfrom dynamic_constraint_rewards.utilities import get_all_utility_functions\n\ndef get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs):\n    \'\'\'\n    Relaxed reward for ceiling lamps being near bed corners.\n    Uses soft assignment: each lamp contributes based on proximity to nearest corner.\n    Reward = average over lamps of: exp(-min_distance^2 / (2*sigma^2)) - 1\n    This gives smoother gradients and is more learnable.\n    \'\'\'\n    utility_functions = get_all_utility_functions()\n    \n    B = parsed_scenes[\'positions\'].shape[0]\n    N = parsed_scenes[\'positions\'].shape[1]\n    rewards = torch.zeros(B, device=parsed_scenes[\'device\'])\n    \n    # Find class indices\n    labels_to_idx = {v: k for k, v in idx_to_labels.items()}\n    ceiling_lamp_idx = labels_to_idx["ceiling_lamp"]\n    bed_indices = [labels_to_idx["double_bed"], labels_to_idx["single_bed"], labels_to_idx["kids_bed"]]\n    \n    sigma = 0.5  # Distance scale in meters for exponential decay\n    \n    for i in range(B):\n        positions = parsed_scenes[\'positions\'][i]  # (N, 3)\n        sizes = parsed_scenes[\'sizes\'][i]  # (N, 3)\n        orientations = parsed_scenes[\'orientations\'][i]  # (N, 2)\n        object_indices = parsed_scenes[\'object_indices\'][i]  # (N,)\n        is_empty = parsed_scenes[\'is_empty\'][i]  # (N,)\n        \n        # Find ceiling lamps\n        lamp_mask = (object_indices == ceiling_lamp_idx) & (~is_empty)\n        lamp_positions = positions[lamp_mask]  # (num_lamps, 3)\n        \n        # Find beds\n        bed_mask = torch.zeros_like(is_empty, dtype=torch.bool)\n        for bed_idx in bed_indices:\n            bed_mask |= (object_indices == bed_idx)\n        bed_mask &= (~is_empty)\n        \n        if lamp_mask.sum() == 0 or bed_mask.sum() == 0:\n            rewards[i] = -1.0  # No lamps or beds\n            continue\n        \n        # Get bed info (use first bed if multiple)\n        bed_idx_tensor = torch.where(bed_mask)[0][0]\n        bed_pos = positions[bed_idx_tensor]  # (3,)\n        bed_size = sizes[bed_idx_tensor]  # (3,)\n        bed_orient = orientations[bed_idx_tensor]  # (2,)\n        \n        # Calculate bed corners in XZ plane\n        cos_theta = bed_orient[0]\n        sin_theta = bed_orient[1]\n        \n        # Half-sizes\n        half_x = bed_size[0]\n        half_z = bed_size[2]\n        \n        # Four corners relative to bed center (in local frame)\n        local_corners = torch.tensor([\n            [half_x, half_z],\n            [half_x, -half_z],\n            [-half_x, half_z],\n            [-half_x, -half_z]\n        ], device=parsed_scenes[\'device\'])\n        \n        # Rotate corners to world frame\n        rotation_matrix = torch.tensor([\n            [cos_theta, -sin_theta],\n            [sin_theta, cos_theta]\n        ], device=parsed_scenes[\'device\'])\n        \n        world_corners = torch.matmul(local_corners, rotation_matrix.T)  # (4, 2)\n        world_corners[:, 0] += bed_pos[0]  # Add bed x\n        world_corners[:, 1] += bed_pos[2]  # Add bed z\n        \n        # For each lamp, compute proximity to nearest corner\n        lamp_rewards = []\n        for lamp_pos in lamp_positions:\n            lamp_xz = torch.tensor([lamp_pos[0], lamp_pos[2]], device=parsed_scenes[\'device\'])\n            distances = torch.norm(world_corners - lamp_xz.unsqueeze(0), dim=1)  # (4,)\n            min_dist = distances.min()\n            \n            # Exponential decay: reward ranges from -1 (far) to 0 (at corner)\n            lamp_reward = torch.exp(-min_dist**2 / (2 * sigma**2)) - 1.0\n            lamp_rewards.append(lamp_reward)\n        \n        # Average reward over all lamps\n        rewards[i] = torch.stack(lamp_rewards).mean()\n    \n    return rewards\n\ndef test_reward(idx_to_labels, room_type, floor_polygons, **kwargs):\n    utility_functions = get_all_utility_functions()\n    create_scene = utility_functions["create_scene_for_testing"]["function"]\n    \n    # Scene 1: 4 lamps perfectly at bed corners (satisfies well)\n    # Bed at (0, 0.5, 0) with size (1.0, 0.4, 1.5) means corners at (±1.0, ±1.5)\n    scene_1 = create_scene(\n        room_type=room_type,\n        num_objects=5,\n        class_label_indices=[8, 3, 3, 3, 3],  # double_bed, 4 ceiling_lamps\n        translations=[(0, 0.5, 0), (1.0, 2.8, 1.5), (1.0, 2.8, -1.5), (-1.0, 2.8, 1.5), (-1.0, 2.8, -1.5)],\n        sizes=[(1.0, 0.4, 1.5), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2)],\n        orientations=[(1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]\n    )\n    \n    # Scene 2: 4 lamps moderately offset from corners\n    scene_2 = create_scene(\n        room_type=room_type,\n        num_objects=5,\n        class_label_indices=[8, 3, 3, 3, 3],\n        translations=[(0, 0.5, 0), (1.5, 2.8, 2.0), (1.5, 2.8, -2.0), (-1.5, 2.8, 2.0), (-1.5, 2.8, -2.0)],\n        sizes=[(1.0, 0.4, 1.5), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2), (0.2, 0.05, 0.2)],\n        orientations=[(1, 0), (1, 0), (1, 0), (1, 0), (1, 0)]\n    )\n    \n    # Scene 3: No lamps (fails)\n    scene_3 = create_scene(\n        room_type=room_type,\n        num_objects=1,\n        class_label_indices=[8],\n        translations=[(0, 0.5, 0)],\n        sizes=[(1.0, 0.4, 1.5)],\n        orientations=[(1, 0)]\n    )\n    \n    tensor_keys = [k for k in scene_1 if isinstance(scene_1[k], torch.Tensor)]\n    parsed_scenes = {\n        k: torch.cat([scene_1[k], scene_2[k], scene_3[k]], dim=0)\n        for k in tensor_keys\n    }\n    parsed_scenes[\'room_type\'] = room_type\n    parsed_scenes[\'device\'] = scene_1[\'device\']\n    \n    rewards = get_reward(parsed_scenes, idx_to_labels, room_type, floor_polygons, **kwargs)\n    print("Rewards:", rewards)\n    print("Expected: Scene 1 close to 0 (perfect), Scene 2 more negative (offset), Scene 3 = -1.0")\n    assert rewards.shape[0] == 3\n    assert rewards[0] >= -0.1, f"Scene 1 should have reward close to 0 (got {rewards[0]})"\n    assert rewards[1] < rewards[0] and rewards[1] > -0.9, f"Scene 2 should have moderate penalty (got {rewards[1]})"\n    assert rewards[2] == -1.0, f"Scene 3 should have reward -1.0, got {rewards[2]}"', 'success_threshold': -0.3}]
        Final Universal Reward Functions: {'non_penetration': {'function': 'compute_non_penetration_reward', 'description': '\n    Calculate reward based on non-penetration constraint using penetration depth.\n\n    Following the approach from original authors: reward = sum of negative signed distances.\n    When objects overlap, we get positive penetration depth, so reward is negative.\n\n    Args:\n        parsed_scene: Dict returned by parse_and_descale_scenes()\n\n    Returns:\n        rewards: Tensor of shape (B,) with non-penetration rewards for each scene\n    '}, 'not_out_of_bound': {'function': 'compute_boundary_violation_reward', 'description': "\n    Compute boundary violation reward using cached SDF grids.\n\n    **IMPORTANT**: Call `precompute_sdf_cache()` once before training to generate cache!\n\n    Args:\n        parsed_scene: Dictionary with positions, sizes, is_empty, device\n        floor_polygons: (B, num_vertices, 2) - only needed if cache doesn't exist\n        indices: (B,) - scene indices for SDF lookup\n        grid_resolution: SDF grid resolution\n        sdf_cache_dir: Directory containing cached SDF grids\n\n    Returns:\n        rewards: (B, 1) - sum of negative violation distances per scene\n    "}, 'accessibility': {'function': 'compute_accessibility_reward', 'description': "\n    Compute accessibility reward using cached floor grids or computing on-the-fly.\n\n    Returns dict with 3 components:\n    - coverage_ratio: [0, 1] - fraction of floor reachable from largest region\n    - num_regions: [1, ∞) - number of disconnected regions\n    - avg_clearance: meters - average distance to nearest obstacle in reachable area\n\n    Args:\n        parsed_scenes: Dictionary with positions, sizes, is_empty, device, object_types\n        floor_polygons: (B, num_vertices, 2) - floor polygon vertices\n        is_val: Whether this is validation split\n        indices: (B,) - scene indices for cache lookup\n        accessibility_cache: Pre-loaded AccessibilityCache instance (optional)\n        grid_resolution: Grid resolution in meters (default 0.2m = 20cm)\n        agent_radius: Agent radius in meters (default 0.15m = 15cm)\n        save_viz: Whether to save visualization images\n        viz_dir: Directory to save visualizations\n\n    Returns:\n        Dictionary with:\n        - 'coverage_ratio': (B,) - reachable area ratio [0, 1]\n        - 'num_regions': (B,) - number of disconnected regions [1, ∞)\n        - 'avg_clearance': (B,) - average clearance in meters\n    "}, 'gravity_following': {'function': 'compute_gravity_following_reward', 'description': '\n    Calculate gravity-following reward based on how close objects are to the ground.\n\n    Objects should rest on the floor (y_min ≈ 0), except for ceiling objects.\n    Only penalizes objects that are MORE than tolerance away from the floor(both sinking and floating cases).\n\n    Args:\n        parsed_scene: Dict returned by parse_and_descale_scenes()\n        tolerance: Distance threshold in meters (default 0.01m = 1cm)\n\n    Returns:\n        rewards: Tensor of shape (B,) with gravity-following rewards\n    '}}
    